{"title":"java NIO","date":"2021-02-11T08:30:01.000Z","date_formatted":{"ll":"Feb 11, 2021","L":"02/11/2021","MM-DD":"02-11"},"link":"2021/02/11/xuyuntian/java/io_and_thread/NIO","tags":["基础知识"],"categories":["java"],"updated":"2021-02-12T02:18:33.965Z","content":"<h1 id=\"java-nio\">java NIO<a title=\"#java-nio\" href=\"#java-nio\"></a></h1>\n<h2 id=\"channel\">Channel<a title=\"#channel\" href=\"#channel\"></a></h2>\n<p>channel类似于stream但它既可以进行读，也可以进行写.</p>\n<p><img src=\"imgs/xuyuntian/nio/overview-channels-buffers.png\" alt=\"\"><br>\n<strong>从channel读数据到buffer中，和从buffer写数据到channel中</strong><br>\n下面有channel读和写的例子</p>\n<h3 id=\"read\">read<a title=\"#read\" href=\"#read\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void testRead() throws IOException &#123;</span><br><span class=\"line\">    RandomAccessFile raf &#x3D; new RandomAccessFile(&quot;NIO.txt&quot;,&quot;rw&quot;);</span><br><span class=\"line\">    FileChannel fCh &#x3D;  raf.getChannel();</span><br><span class=\"line\">    ByteBuffer buf &#x3D; ByteBuffer.allocate(8);</span><br><span class=\"line\">    while (fCh.read(buf) !&#x3D;-1)&#123;</span><br><span class=\"line\">        buf.flip();</span><br><span class=\"line\">        while (buf.hasRemaining())&#123;</span><br><span class=\"line\">            System.out.print((char)buf.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        buf.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用channel读的时候，它只会将channel的数据写入[position,limit-1],如果limit-position &lt;=0,则不会读数据到buffer中。clear()方法会改变position和limit的值，后面buffer的内容会有介绍</p>\n</blockquote>\n<h3 id=\"write\">write<a title=\"#write\" href=\"#write\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void testWrite() throws IOException &#123;</span><br><span class=\"line\">    ByteBuffer buffer &#x3D; ByteBuffer.allocate(8);</span><br><span class=\"line\">    byte[] chars &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;&#125;;</span><br><span class=\"line\">    buffer.put(chars);</span><br><span class=\"line\">    RandomAccessFile randomAccessFile &#x3D; new RandomAccessFile(&quot;text.txt&quot;,&quot;rw&quot;);</span><br><span class=\"line\">    FileChannel fileChannel &#x3D; randomAccessFile.getChannel();</span><br><span class=\"line\">    fileChannel.write((ByteBuffer) buffer.rewind());</span><br><span class=\"line\">    fileChannel.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用channel写数据的时候,会将buffer中[position,limit-1]之间的数据写入channel中，如果limit-position &lt;=0,则不会写入任何数据。在buffer放入数据时，postion会移动，所以，如果要重新使用它要调用rewind方法重置postion的位置。</p>\n</blockquote>\n<h3 id=\"补充\">补充<a title=\"#补充\" href=\"#补充\"></a></h3>\n<ul>\n<li>channel的write/read有很多重载方法，可以写/读入多个buffer。也可以指定读/写的初始位置</li>\n<li>channel可以将channel中的数据直接写入另外一个channel中</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile source &#x3D; new RandomAccessFile(&quot;NIO.txt&quot;,&quot;rw&quot;);</span><br><span class=\"line\">RandomAccessFile target &#x3D; new RandomAccessFile(&quot;TIO.txt&quot;,&quot;rw&quot;);</span><br><span class=\"line\">FileChannel sourceChannel &#x3D; source.getChannel();</span><br><span class=\"line\">FileChannel targetChannel &#x3D; target.getChannel();</span><br><span class=\"line\">long position &#x3D; 0;</span><br><span class=\"line\">long count    &#x3D; sourceChannel.size();</span><br><span class=\"line\">targetChannel.transferFrom(sourceChannel,position,count);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>但它有上限为 2<sup>23</sup></p>\n</blockquote>\n<h2 id=\"buffer\">buffer<a title=\"#buffer\" href=\"#buffer\"></a></h2>\n<p>buffer是一块内存的空间，只不过进行了包装可以更方便地使用<br>\n它有4个核心的字段</p>\n<ul>\n<li>postion</li>\n<li>limit</li>\n<li>capacity</li>\n<li>mark</li>\n</ul>\n<p>postion在读中表示读到的位置，在写中表示写到的位置<br>\nlimit 代表buffer可以被写或者读的最后一个位置<br>\ncapacity 代表buffer的容量<br>\nmark 是个标记字段,用于标记当前postion的位置，可以通过它让postion回到mark的位置。</p>\n<blockquote>\n<pre><code>ByteBuffer buf = ByteBuffer.allocate(8);\n</code></pre>\n</blockquote>\n<p>对于上面这段代码，buffer创建之后它的<br>\npostion = 0,limit = capacity = 8,mark = -1</p>\n<p>postion 使用channel读数据到buffer中时，postion会不断移动，直到到达limt或者channel没有数据。<br>\n<strong>buffer它有以下几个核心方法</strong></p>\n<h3 id=\"flip()\">flip()<a title=\"#flip()\" href=\"#flip()\"></a></h3>\n<p>一般情况下在channel写入buffer后使用，用于开始从buffer中读数据<br>\n它会产生以下效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">limit &#x3D; postion;</span><br><span class=\"line\">postion &#x3D; 0;</span><br><span class=\"line\">mark &#x3D; -1;</span><br></pre></td></tr></table></figure>\n<h3 id=\"hasremaining()\">hasRemaining()<a title=\"#hasremaining()\" href=\"#hasremaining()\"></a></h3>\n<p>用于判断buffer中是否能够读或者写</p>\n<blockquote>\n<p>return postion &lt; limit;</p>\n</blockquote>\n<h3 id=\"rewind()\">rewind()<a title=\"#rewind()\" href=\"#rewind()\"></a></h3>\n<p>清除标记,且将postion置为0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position &#x3D; 0;</span><br><span class=\"line\">mark &#x3D; -1;</span><br></pre></td></tr></table></figure>\n<h3 id=\"clear()\">clear()<a title=\"#clear()\" href=\"#clear()\"></a></h3>\n<p>limit设为容量，清除标记，postion设为0，写数据到buffer前,buffer被使用过，如果希望重新利用整个buffer便需要调用它</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position &#x3D; 0;</span><br><span class=\"line\">limit &#x3D; capacity;</span><br><span class=\"line\">mark &#x3D; -1;</span><br></pre></td></tr></table></figure>\n<h3 id=\"compact()\">compact()<a title=\"#compact()\" href=\"#compact()\"></a></h3>\n<p>它会将buffer中[postion,limit-1] 处的元素复制到[0,limit-postion-1]处<br>\n然后将postion设为limit-position,limit置为capacity,mark置为-1;<br>\n一般情况下用于将未读/或者未写完的数据保留，然后继续使用buffer.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.arraycopy(buf, postion, buf, position, limit - position);</span><br><span class=\"line\">position &#x3D;  limit-position;</span><br><span class=\"line\">limit &#x3D; capacity;</span><br><span class=\"line\">mark - -1;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mark()-和-reset()\">mark() 和 reset()<a title=\"#mark()-和-reset()\" href=\"#mark()-和-reset()\"></a></h3>\n<p>mark()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mark &#x3D; position;</span><br></pre></td></tr></table></figure>\n<p>reset()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position &#x3D; mark;</span><br></pre></td></tr></table></figure>\n<p>如果想读一部分数据后，想再读之前的数据可以使用它们。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.mark();</span><br><span class=\"line\">&#x2F;&#x2F;往前读一部分，使用它</span><br><span class=\"line\">....</span><br><span class=\"line\">....</span><br><span class=\"line\">&#x2F;&#x2F;回到标记的位置</span><br><span class=\"line\">buffer.reset();</span><br></pre></td></tr></table></figure>\n<h3 id=\"equals()-和-compareto()\">equals() 和 compareTo()<a title=\"#equals()-和-compareto()\" href=\"#equals()-和-compareto()\"></a></h3>\n<ol>\n<li>equals()<br>\n对于2个buffer，它们会分别对比</li>\n</ol>\n<ul>\n<li>buffer类型是否相同</li>\n<li>limit-position是否相同</li>\n<li>[position,limit-1]之间的每个元素是否相同<br>\n以上条件都成立时它才返回true</li>\n</ul>\n<ol start=\"2\">\n<li>compareTo()<br>\n类似于字符串的对比，只不过范围为[position,limit-1]之间的元素</li>\n</ol>\n<h2 id=\"selector\">Selector<a title=\"#selector\" href=\"#selector\"></a></h2>\n<p><img src=\"imgs/xuyuntian/nio/selector.png\" alt=\"\"><br>\nselector是nio的核心组件，channel可以注册到selector上，并指定它感兴趣的事件。selector的channel须支持非阻塞模式,才能有效地使用它。</p>\n<h2 id=\"使用selector的一个例子\">使用selector的一个例子<a title=\"#使用selector的一个例子\" href=\"#使用selector的一个例子\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void sockChannelTest() throws IOException &#123;</span><br><span class=\"line\">    ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class=\"line\">    serverSocketChannel.configureBlocking(false);</span><br><span class=\"line\">    ServerSocket serverSocket &#x3D; serverSocketChannel.socket();</span><br><span class=\"line\">    serverSocket.bind(new InetSocketAddress(7777));</span><br><span class=\"line\">    Selector selector &#x3D; Selector.open();</span><br><span class=\"line\">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    final ByteBuffer buffer &#x3D; ByteBuffer.wrap(&quot;服务端的消息\\n&quot;.getBytes());</span><br><span class=\"line\">    for (; ; ) &#123;</span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\">        Set&lt;SelectionKey&gt; readyKeys &#x3D; selector.selectedKeys();</span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; iterator &#x3D; readyKeys.iterator();</span><br><span class=\"line\">        while (iterator.hasNext()) &#123;</span><br><span class=\"line\">            SelectionKey key &#x3D; iterator.next();</span><br><span class=\"line\">            iterator.remove();</span><br><span class=\"line\">            if (key.isAcceptable()) &#123;</span><br><span class=\"line\">                ServerSocketChannel server &#x3D; (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                SocketChannel client &#x3D; server.accept();</span><br><span class=\"line\">                client.configureBlocking(false);</span><br><span class=\"line\">                client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, buffer.duplicate();</span><br><span class=\"line\">                System.out.println(&quot;客户端连接上了&quot;);</span><br><span class=\"line\">            &#125; else if (key.isReadable()) &#123;</span><br><span class=\"line\">                ByteBuffer buffer1 &#x3D; ByteBuffer.allocate(1024);</span><br><span class=\"line\">                SocketChannel client &#x3D; (SocketChannel) key.channel();</span><br><span class=\"line\">                client.read(buffer1);</span><br><span class=\"line\">                buffer1.flip();</span><br><span class=\"line\">                System.out.print(&quot;------客户端的数据:&quot;);</span><br><span class=\"line\">                while (buffer1.hasRemaining()) &#123;</span><br><span class=\"line\">                    System.out.print((char) buffer1.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                client.register(selector, SelectionKey.OP_WRITE, buffer.duplicate());</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; else if (key.isWritable()) &#123;</span><br><span class=\"line\">                SocketChannel client &#x3D; (SocketChannel) key.channel();</span><br><span class=\"line\">                ByteBuffer buffer1 &#x3D; (ByteBuffer) key.attachment();</span><br><span class=\"line\">                while (buffer1.hasRemaining()) &#123;</span><br><span class=\"line\">                    if (client.write(buffer1) &#x3D;&#x3D; 0) break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                client.register(selector, SelectionKey.OP_READ, buffer.duplicate());</span><br><span class=\"line\">    &#x2F;&#x2F;                    client.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用selector\">使用selector<a title=\"#使用selector\" href=\"#使用selector\"></a></h3>\n<p>使用selector步骤大致如下</p>\n<ul>\n<li>创建selector</li>\n<li>将channel注册到selector中，并指定监听事件</li>\n<li>调用select()方法获取就绪的channel</li>\n<li>调用selectedKeys()获取就绪的集合</li>\n<li>迭代selectedKeys进行数据的处理</li>\n</ul>\n<p>其中监听的事件有这几种:</p>\n<ol>\n<li>Connect -&gt; SelectionKey.OP_CONNECT</li>\n<li>Accept -&gt; SelectionKey.OP_ACCEPT</li>\n<li>Read -&gt; SelectionKey.OP_READ</li>\n<li>Write -&gt; SelectionKey.OP_WRITE</li>\n</ol>\n<p>它的值是一个int类型，本质上是个<strong>bitMap</strong>,可以通过 | 操作符表示多个。</p>\n<p>select()方法是个阻塞的方法，它会等待直到selector中有channel已经就绪。</p>\n<p>selectedKeys()方法返回一个Set<SelectionKey>,可以通过SelectionKey的来获取当前的channel。</p>\n<h2 id=\"说明\">说明<a title=\"#说明\" href=\"#说明\"></a></h2>\n<h3 id=\"bitmap\">bitMap<a title=\"#bitmap\" href=\"#bitmap\"></a></h3>\n<p>可以通过bit位是存在1来表示true,存在0表示false;类似于Map&lt;Integer,Boolean&gt;,只不过它key的范围为bit位的个数。</p>\n<h2 id=\"参考文章\">参考文章<a title=\"#参考文章\" href=\"#参考文章\"></a></h2>\n<blockquote>\n<p><a href=\"http://tutorials.jenkov.com/java-nio/index.html\" target=\"_blank\">java nio tutorial</a></p>\n</blockquote>\n","next":{"title":"java类型转换","link":"2021/02/02/xuyuntian/java/强制类型转换"},"plink":"http://example.com/2021/02/11/xuyuntian/java/io_and_thread/NIO/","toc":[{"id":"java-nio","title":"java NIO","index":"1","children":[{"id":"channel","title":"Channel","index":"1.1","children":[{"id":"read","title":"read","index":"1.1.1"},{"id":"write","title":"write","index":"1.1.2"},{"id":"补充","title":"补充","index":"1.1.3"}]},{"id":"buffer","title":"buffer","index":"1.2","children":[{"id":"flip()","title":"flip()","index":"1.2.1"},{"id":"hasremaining()","title":"hasRemaining()","index":"1.2.2"},{"id":"rewind()","title":"rewind()","index":"1.2.3"},{"id":"clear()","title":"clear()","index":"1.2.4"},{"id":"compact()","title":"compact()","index":"1.2.5"},{"id":"mark()-和-reset()","title":"mark() 和 reset()","index":"1.2.6"},{"id":"equals()-和-compareto()","title":"equals() 和 compareTo()","index":"1.2.7"}]},{"id":"selector","title":"Selector","index":"1.3"},{"id":"使用selector的一个例子","title":"使用selector的一个例子","index":"1.4","children":[{"id":"使用selector","title":"使用selector","index":"1.4.1"}]},{"id":"说明","title":"说明","index":"1.5","children":[{"id":"bitmap","title":"bitMap","index":"1.5.1"}]},{"id":"参考文章","title":"参考文章","index":"1.6"}]}]}