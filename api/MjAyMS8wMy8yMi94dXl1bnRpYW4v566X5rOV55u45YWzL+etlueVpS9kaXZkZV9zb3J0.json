{"title":"分治排序","date":"2021-03-22T09:40:00.000Z","date_formatted":{"ll":"Mar 22, 2021","L":"03/22/2021","MM-DD":"03-22"},"link":"2021/03/22/xuyuntian/算法相关/策略/divde_sort","tags":["分治","排序"],"categories":["算法"],"updated":"2021-03-22T09:40:14.762Z","content":"<h1 id=\"分治排序\">分治排序<a title=\"#分治排序\" href=\"#分治排序\"></a></h1>\n<p>下面介绍分治法处理排序:</p>\n<ul>\n<li>快排</li>\n<li>归并排序</li>\n</ul>\n<h2 id=\"快排\">快排<a title=\"#快排\" href=\"#快排\"></a></h2>\n<p>快排的基本原理:</p>\n<ol>\n<li>选择一个基准，将第一个元素和基准交换.</li>\n<li>用双指针，l,r分别来表示，左右可以填入数字的索引，循环的起点</li>\n<li>首先从右向左扫描将第一个不大于基准的放入左侧l处，并增加l（l处已经填入数据，下次从l+1处开始）</li>\n<li>从左向右扫描，将第一个大于基准的数，放入右侧，并减少r(r位置的数，在步骤3处，已经放到了左侧，所以填入左侧数，不会产生影响)</li>\n<li>重复，直到 l == r</li>\n<li>将基准放入r（l）处 (基准已经被第一个不大于它的数覆盖了，所以要将它归位到拆分的位置)</li>\n<li>拆分数组，重复 2 ～6</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void quickSort(int[] A,int l,int r)&#123;</span><br><span class=\"line\">    if(l &gt;&#x3D; r) return;</span><br><span class=\"line\">    int ol &#x3D; l;</span><br><span class=\"line\">    int or &#x3D; r;</span><br><span class=\"line\">    int val &#x3D; A[l];</span><br><span class=\"line\">    while(l &lt; r)&#123;</span><br><span class=\"line\">        while(r &gt; l &amp;&amp; A[r] &gt;&#x3D; val) r--;</span><br><span class=\"line\">        if(l &lt; r)&#123;</span><br><span class=\"line\">            A[l++] &#x3D; A[r];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while( l &lt; r &amp;&amp; A[l] &lt;val ) l++;</span><br><span class=\"line\">        if( l &lt; r)&#123;</span><br><span class=\"line\">            A[r--] &#x3D; A[l];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    A[l] &#x3D; val;</span><br><span class=\"line\">    quickSort(A,ol,l-1);</span><br><span class=\"line\">    quickSort(A,l+1,or);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意，这里没有随机选择基准，以左边第一个数为基准，所以没有交换</p>\n</blockquote>\n<p>排序的步骤如下图:<br>\n<img src=\"imgs/xuyuntian/alg/quick_sort_1.png\" alt=\"\"></p>\n<h2 id=\"归并排序\">归并排序<a title=\"#归并排序\" href=\"#归并排序\"></a></h2>\n<p>要了解归并排序，首先得了解将2个有序的数组合并成一个新的有序数组的方法。<br>\n对于有序数组A,B,只要O(N)的时间便可以将它排序成新的数组C<br>\n例如[1,2,4] 和[3,5]。合并的过程很简单,每个数组维护一个指针，指向它的索引。<br>\n用一个新的数组来保存结果。<br>\n对比指针处的数字，小的数字放入新的数组，并增加所属数组的指针。<br>\n最后，将剩余数组的其他数据拷贝到新数组中。</p>\n<p>伪代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] A...</span><br><span class=\"line\">int[] B...</span><br><span class=\"line\">int[] C...</span><br><span class=\"line\">int i&#x3D;0;</span><br><span class=\"line\">int j&#x3D;0;</span><br><span class=\"line\">while(i &lt; A.length and j &lt; A.length):</span><br><span class=\"line\">    if A[i] &gt;&#x3D; B[j]:</span><br><span class=\"line\">        C.push(A[i++])</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        C.push(B[j++]);</span><br><span class=\"line\">&#x2F;&#x2F;必有一个数组先空        </span><br><span class=\"line\">if i &lt; A.length:</span><br><span class=\"line\">    C.pushAll(A.range(i,A.length))&#x2F;&#x2F;将A中剩余的元素放到C中</span><br><span class=\"line\">if j &lt; B.length:</span><br><span class=\"line\">    C.pushAll(B.range(j,B.length))&#x2F;&#x2F;将C中剩余的元素放到C中</span><br></pre></td></tr></table></figure>\n<p>那么，如果将A数组进行拆分划分成[left,mid],[mid+1,right]的话，如果保证[left,mid],[mid+1,right]位置的数据有序的话，便产生了以下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void merge(int A[],int left,int mid,int right)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;用2个临时数组保存数据，然后再复制到原数组</span><br><span class=\"line\">    int[] L &#x3D; Arrays.copyOfRange(A,left,mid+1);</span><br><span class=\"line\">    int[] R &#x3D; Arrays.copyOfRange(A,mid+1,right+1);</span><br><span class=\"line\">    int l &#x3D; 0;</span><br><span class=\"line\">    int r &#x3D; 0;</span><br><span class=\"line\">    while (l &lt; L.length &amp;&amp; r &lt; R.length)&#123;</span><br><span class=\"line\">        if(L[l] &lt; R[r])&#123;</span><br><span class=\"line\">            A[left++] &#x3D; L[l++];</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            A[left++] &#x3D; R[r++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while (l &lt; L.length) A[left++] &#x3D; L[l++];</span><br><span class=\"line\">    while (r &lt; R.length) A[left++] &#x3D; R[r++];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于单个元素来说，它一定有序。归并排序首先将数组拆分成单个元素，然后将单个元素合并成2个元素，有序的2个元素再两两合并成4个有序元素以此类推,代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void mergeSort(int[] A,int l,int r)&#123;</span><br><span class=\"line\">    if(l &gt;&#x3D; r) return;</span><br><span class=\"line\">    int mid &#x3D; l + (r-l)&#x2F;2;</span><br><span class=\"line\">    mergeSort(A,l,mid);</span><br><span class=\"line\">    mergeSort(A,mid+1,r);</span><br><span class=\"line\">    merge(A,l,mid,r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>基本步骤如下图</strong><br>\n<img src=\"imgs/xuyuntian/alg/r_merge_sort.png\" alt=\"\"></p>\n<p>其中它还有中非递归写法，这种写法与递归写法并不等同（合并，拆分过程不一样）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void mergeSortWithOutRecursion(int[] A,int l,int r)&#123;</span><br><span class=\"line\">    int len &#x3D; r - l + 1;</span><br><span class=\"line\">    int cursor &#x3D; 1;&#x2F;&#x2F;合并的大小</span><br><span class=\"line\">    while (cursor &lt;&#x3D; len)&#123;</span><br><span class=\"line\">        cursor *&#x3D;2;</span><br><span class=\"line\">        int i &#x3D; l;</span><br><span class=\"line\">        while (i &lt;&#x3D; r)&#123;</span><br><span class=\"line\">            int nL &#x3D; i;</span><br><span class=\"line\">            int mid &#x3D; nL + cursor&#x2F;2 -1;&#x2F;&#x2F;核心</span><br><span class=\"line\">            int nR &#x3D; Math.min(r,nL + cursor -1);</span><br><span class=\"line\">            if(mid &lt; nR) merge(A,nL,mid,nR);</span><br><span class=\"line\">            i +&#x3D; cursor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的步骤如下<br>\n<img src=\"imgs/xuyuntian/alg/no_r_merge_sort.png\" alt=\"\"></p>\n<p>递归写法和非递归这2种拆分的步骤不一样:</p>\n<ul>\n<li>递归写法将数组一分为2，直到不能分为后，再合并</li>\n<li>非递归写法直接按照2的指数来连续合并,mid的位置并不是l + (r-1)/2,而是l+ cursor/2。如果位置超出了r的话，就不需要合并了。</li>\n</ul>\n","next":{"title":"矩阵和","link":"2021/03/17/xuyuntian/算法相关/策略/dp_matrix"},"plink":"http://example.com/2021/03/22/xuyuntian/算法相关/策略/divde_sort/","toc":[{"id":"分治排序","title":"分治排序","index":"1","children":[{"id":"快排","title":"快排","index":"1.1"},{"id":"归并排序","title":"归并排序","index":"1.2"}]}]}