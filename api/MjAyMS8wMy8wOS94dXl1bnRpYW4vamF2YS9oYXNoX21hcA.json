{"title":"HashMap 源码解析","date":"2021-03-09T10:16:01.000Z","date_formatted":{"ll":"Mar 9, 2021","L":"03/09/2021","MM-DD":"03-09"},"link":"2021/03/09/xuyuntian/java/hash_map","tags":["基础知识"],"categories":["java"],"updated":"2021-03-09T04:41:05.158Z","content":"<h1 id=\"hashmap-源码解析\">HashMap 源码解析<a title=\"#hashmap-源码解析\" href=\"#hashmap-源码解析\"></a></h1>\n<p>HashMap时一种根据key快速查找value的数据结构，一般情况下它查找的时间复杂度为o(1)。在jdk8中，它的极端情况是lg(N)，下面通过分析它的结构来了解它的功能是如何实现的。</p>\n<p>它的字段如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transient Node&lt;K,V&gt;[] table;&#x2F;&#x2F;table,存储数据</span><br><span class=\"line\">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;&#x2F;&#x2F;与map绑定，任何操作将会直接操作map</span><br><span class=\"line\">transient int size;&#x2F;&#x2F;当前数据的数量</span><br><span class=\"line\">transient int modCount;&#x2F;&#x2F;每次修改后，该值会增加(用迭代器删除除外)</span><br><span class=\"line\">final float loadFactor;&#x2F;&#x2F;控制下次扩容的参数    </span><br><span class=\"line\">int threshold;&#x2F;&#x2F;指定容量时，用它保存初始容量，有初始容量后，用来保存扩容时的边界容量</span><br></pre></td></tr></table></figure>\n<p>它有如下的常量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F;不指定容量时，默认的初始容量</span><br><span class=\"line\">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F;最大容量 (table的最大length)</span><br><span class=\"line\">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;&#x2F;&#x2F;默认的loadFactor</span><br><span class=\"line\">static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;&#x2F;节点树化时的触发大小</span><br><span class=\"line\">static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;&#x2F;节点解除树化的大小</span><br><span class=\"line\">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;&#x2F;&#x2F;只有Node的总数大于等于它时，节点才会触发树化</span><br></pre></td></tr></table></figure>\n<h2 id=\"hashmap中node的种类\">HashMap中Node的种类<a title=\"#hashmap中node的种类\" href=\"#hashmap中node的种类\"></a></h2>\n<p>HashMap中table的类型是Node&lt;K,V&gt;的数组，而Node有2种，通过继承来实现多态。</p>\n<h3 id=\"1.-node\">1. Node<a title=\"#1.-node\" href=\"#1.-node\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int hash;</span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        this.hash &#x3D; hash;</span><br><span class=\"line\">        this.key &#x3D; key;</span><br><span class=\"line\">        this.value &#x3D; value;</span><br><span class=\"line\">        this.next &#x3D; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final K getKey()        &#123; return key; &#125;</span><br><span class=\"line\">    public final V getValue()      &#123; return value; &#125;</span><br><span class=\"line\">    public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final int hashCode() &#123;</span><br><span class=\"line\">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final V setValue(V newValue) &#123;</span><br><span class=\"line\">        V oldValue &#x3D; value;</span><br><span class=\"line\">        value &#x3D; newValue;</span><br><span class=\"line\">        return oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final boolean equals(Object o) &#123;</span><br><span class=\"line\">        if (o &#x3D;&#x3D; this)</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        if (o instanceof Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Node类它有4个字段</p>\n<ol>\n<li>hash</li>\n<li>key</li>\n<li>value</li>\n<li>next</li>\n</ol>\n<p>hash记录key的hash值，计算方式为key.hashCode() ^ (key.hashCode() &gt;&gt; 16),右移动16位的作用是为了将高位和低位做下简单的关联，在一定程度下减少碰撞。特别是hashCode很大的时候，不做这步处理会导致高bit位使用不到，导致只计算低位置的hash了。<br>\nkey,存储key的值<br>\nvalue,存储value的值<br>\nnext,它下个节点的值</p>\n<p>它在table中的分布可能如下</p>\n<p><img src=\"imgs/xuyuntian/java_util/hash_node.png\" alt=\"\" class=\"φcx\"></p>\n<h3 id=\"2.-treenode\">2. TreeNode<a title=\"#2.-treenode\" href=\"#2.-treenode\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion</span><br><span class=\"line\">    boolean red;</span><br><span class=\"line\">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        super(hash, key, val, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class=\"line\">        for (TreeNode&lt;K,V&gt; r &#x3D; this, p;;) &#123;</span><br><span class=\"line\">            if ((p &#x3D; r.parent) &#x3D;&#x3D; null)</span><br><span class=\"line\">                return r;</span><br><span class=\"line\">            r &#x3D; p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123;</span><br><span class=\"line\">        int n;</span><br><span class=\"line\">        if (root !&#x3D; null &amp;&amp; tab !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0) &#123;</span><br><span class=\"line\">            int index &#x3D; (n - 1) &amp; root.hash;</span><br><span class=\"line\">            TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class=\"line\">            if (root !&#x3D; first) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; rn;</span><br><span class=\"line\">                tab[index] &#x3D; root;</span><br><span class=\"line\">                TreeNode&lt;K,V&gt; rp &#x3D; root.prev;</span><br><span class=\"line\">                if ((rn &#x3D; root.next) !&#x3D; null)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)rn).prev &#x3D; rp;</span><br><span class=\"line\">                if (rp !&#x3D; null)</span><br><span class=\"line\">                    rp.next &#x3D; rn;</span><br><span class=\"line\">                if (first !&#x3D; null)</span><br><span class=\"line\">                    first.prev &#x3D; root;</span><br><span class=\"line\">                root.next &#x3D; first;</span><br><span class=\"line\">                root.prev &#x3D; null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            assert checkInvariants(root);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; p &#x3D; this;</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            int ph, dir; K pk;</span><br><span class=\"line\">            TreeNode&lt;K,V&gt; pl &#x3D; p.left, pr &#x3D; p.right, q;</span><br><span class=\"line\">            if ((ph &#x3D; p.hash) &gt; h)</span><br><span class=\"line\">                p &#x3D; pl;</span><br><span class=\"line\">            else if (ph &lt; h)</span><br><span class=\"line\">                p &#x3D; pr;</span><br><span class=\"line\">            else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">                return p;</span><br><span class=\"line\">            else if (pl &#x3D;&#x3D; null)</span><br><span class=\"line\">                p &#x3D; pr;</span><br><span class=\"line\">            else if (pr &#x3D;&#x3D; null)</span><br><span class=\"line\">                p &#x3D; pl;</span><br><span class=\"line\">            else if ((kc !&#x3D; null ||</span><br><span class=\"line\">                      (kc &#x3D; comparableClassFor(k)) !&#x3D; null) &amp;&amp;</span><br><span class=\"line\">                     (dir &#x3D; compareComparables(kc, k, pk)) !&#x3D; 0)</span><br><span class=\"line\">                p &#x3D; (dir &lt; 0) ? pl : pr;</span><br><span class=\"line\">            else if ((q &#x3D; pr.find(h, k, kc)) !&#x3D; null)</span><br><span class=\"line\">                return q;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                p &#x3D; pl;</span><br><span class=\"line\">        &#125; while (p !&#x3D; null);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class=\"line\">        return ((parent !&#x3D; null) ? root() : this).find(h, k, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static int tieBreakOrder(Object a, Object b) &#123;</span><br><span class=\"line\">        int d;</span><br><span class=\"line\">        if (a &#x3D;&#x3D; null || b &#x3D;&#x3D; null ||</span><br><span class=\"line\">            (d &#x3D; a.getClass().getName().</span><br><span class=\"line\">             compareTo(b.getClass().getName())) &#x3D;&#x3D; 0)</span><br><span class=\"line\">            d &#x3D; (System.identityHashCode(a) &lt;&#x3D; System.identityHashCode(b) ?</span><br><span class=\"line\">                 -1 : 1);</span><br><span class=\"line\">        return d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final void treeify(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; root &#x3D; null;</span><br><span class=\"line\">        for (TreeNode&lt;K,V&gt; x &#x3D; this, next; x !&#x3D; null; x &#x3D; next) &#123;&#x2F;&#x2F;迭代Node节点，并转化成红黑树</span><br><span class=\"line\">            next &#x3D; (TreeNode&lt;K,V&gt;)x.next;</span><br><span class=\"line\">            x.left &#x3D; x.right &#x3D; null;</span><br><span class=\"line\">            if (root &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                x.parent &#x3D; null;</span><br><span class=\"line\">                x.red &#x3D; false;</span><br><span class=\"line\">                root &#x3D; x;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                K k &#x3D; x.key;</span><br><span class=\"line\">                int h &#x3D; x.hash;</span><br><span class=\"line\">                Class&lt;?&gt; kc &#x3D; null;</span><br><span class=\"line\">                for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class=\"line\">                    int dir, ph;</span><br><span class=\"line\">                    K pk &#x3D; p.key;</span><br><span class=\"line\">                    if ((ph &#x3D; p.hash) &gt; h)</span><br><span class=\"line\">                        dir &#x3D; -1;</span><br><span class=\"line\">                    else if (ph &lt; h)</span><br><span class=\"line\">                        dir &#x3D; 1;</span><br><span class=\"line\">                    else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class=\"line\">                              (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class=\"line\">                             (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0)</span><br><span class=\"line\">                        dir &#x3D; tieBreakOrder(k, pk);</span><br><span class=\"line\"></span><br><span class=\"line\">                    TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class=\"line\">                    if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                        x.parent &#x3D; xp;</span><br><span class=\"line\">                        if (dir &lt;&#x3D; 0)</span><br><span class=\"line\">                            xp.left &#x3D; x;</span><br><span class=\"line\">                        else</span><br><span class=\"line\">                            xp.right &#x3D; x;</span><br><span class=\"line\">                        root &#x3D; balanceInsertion(root, x);</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;如果root不是tab[index]的话，将root，放到双向链表的首部，并引用它。</span><br><span class=\"line\">        moveRootToFront(tab, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class=\"line\">        for (Node&lt;K,V&gt; q &#x3D; this; q !&#x3D; null; q &#x3D; q.next) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; p &#x3D; map.replacementNode(q, null);</span><br><span class=\"line\">            if (tl &#x3D;&#x3D; null)</span><br><span class=\"line\">                hd &#x3D; p;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                tl.next &#x3D; p;</span><br><span class=\"line\">            tl &#x3D; p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return hd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class=\"line\">                                   int h, K k, V v) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; kc &#x3D; null;</span><br><span class=\"line\">        boolean searched &#x3D; false;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; root &#x3D; (parent !&#x3D; null) ? root() : this;</span><br><span class=\"line\">        for (TreeNode&lt;K,V&gt; p &#x3D; root;;) &#123;</span><br><span class=\"line\">            int dir, ph; K pk;</span><br><span class=\"line\">            if ((ph &#x3D; p.hash) &gt; h)</span><br><span class=\"line\">                dir &#x3D; -1;</span><br><span class=\"line\">            else if (ph &lt; h)</span><br><span class=\"line\">                dir &#x3D; 1;</span><br><span class=\"line\">            else if ((pk &#x3D; p.key) &#x3D;&#x3D; k || (k !&#x3D; null &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">                return p;</span><br><span class=\"line\">            else if ((kc &#x3D;&#x3D; null &amp;&amp;</span><br><span class=\"line\">                      (kc &#x3D; comparableClassFor(k)) &#x3D;&#x3D; null) ||</span><br><span class=\"line\">                     (dir &#x3D; compareComparables(kc, k, pk)) &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                if (!searched) &#123;</span><br><span class=\"line\">                    TreeNode&lt;K,V&gt; q, ch;</span><br><span class=\"line\">                    searched &#x3D; true;</span><br><span class=\"line\">                    if (((ch &#x3D; p.left) !&#x3D; null &amp;&amp;</span><br><span class=\"line\">                         (q &#x3D; ch.find(h, k, kc)) !&#x3D; null) ||</span><br><span class=\"line\">                        ((ch &#x3D; p.right) !&#x3D; null &amp;&amp;</span><br><span class=\"line\">                         (q &#x3D; ch.find(h, k, kc)) !&#x3D; null))</span><br><span class=\"line\">                        return q;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dir &#x3D; tieBreakOrder(k, pk);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            TreeNode&lt;K,V&gt; xp &#x3D; p;</span><br><span class=\"line\">            if ((p &#x3D; (dir &lt;&#x3D; 0) ? p.left : p.right) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; xpn &#x3D; xp.next;</span><br><span class=\"line\">                TreeNode&lt;K,V&gt; x &#x3D; map.newTreeNode(h, k, v, xpn);</span><br><span class=\"line\">                if (dir &lt;&#x3D; 0)</span><br><span class=\"line\">                    xp.left &#x3D; x;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    xp.right &#x3D; x;</span><br><span class=\"line\">                xp.next &#x3D; x;</span><br><span class=\"line\">                x.parent &#x3D; x.prev &#x3D; xp;</span><br><span class=\"line\">                if (xpn !&#x3D; null)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)xpn).prev &#x3D; x;</span><br><span class=\"line\">                moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class=\"line\">                              boolean movable) &#123;</span><br><span class=\"line\">        int n;</span><br><span class=\"line\">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        int index &#x3D; (n - 1) &amp; hash;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; first &#x3D; (TreeNode&lt;K,V&gt;)tab[index], root &#x3D; first, rl;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; succ &#x3D; (TreeNode&lt;K,V&gt;)next, pred &#x3D; prev;</span><br><span class=\"line\">        if (pred &#x3D;&#x3D; null)</span><br><span class=\"line\">            tab[index] &#x3D; first &#x3D; succ;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            pred.next &#x3D; succ;</span><br><span class=\"line\">        if (succ !&#x3D; null)</span><br><span class=\"line\">            succ.prev &#x3D; pred;</span><br><span class=\"line\">        if (first &#x3D;&#x3D; null)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        if (root.parent !&#x3D; null)</span><br><span class=\"line\">            root &#x3D; root.root();</span><br><span class=\"line\">        if (root &#x3D;&#x3D; null</span><br><span class=\"line\">            || (movable</span><br><span class=\"line\">                &amp;&amp; (root.right &#x3D;&#x3D; null</span><br><span class=\"line\">                    || (rl &#x3D; root.left) &#x3D;&#x3D; null</span><br><span class=\"line\">                    || rl.left &#x3D;&#x3D; null))) &#123;</span><br><span class=\"line\">            tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            &#x2F;&#x2F;这里是删除红黑树的节点，代码省略</span><br><span class=\"line\">        if (movable)</span><br><span class=\"line\">            moveRootToFront(tab, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; b &#x3D; this;</span><br><span class=\"line\">        &#x2F;&#x2F; Relink into lo and hi lists, preserving order</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class=\"line\">        int lc &#x3D; 0, hc &#x3D; 0;</span><br><span class=\"line\">        for (TreeNode&lt;K,V&gt; e &#x3D; b, next; e !&#x3D; null; e &#x3D; next) &#123;</span><br><span class=\"line\">            next &#x3D; (TreeNode&lt;K,V&gt;)e.next;</span><br><span class=\"line\">            e.next &#x3D; null;</span><br><span class=\"line\">            if ((e.hash &amp; bit) &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                if ((e.prev &#x3D; loTail) &#x3D;&#x3D; null)</span><br><span class=\"line\">                    loHead &#x3D; e;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    loTail.next &#x3D; e;</span><br><span class=\"line\">                loTail &#x3D; e;</span><br><span class=\"line\">                ++lc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                if ((e.prev &#x3D; hiTail) &#x3D;&#x3D; null)</span><br><span class=\"line\">                    hiHead &#x3D; e;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    hiTail.next &#x3D; e;</span><br><span class=\"line\">                hiTail &#x3D; e;</span><br><span class=\"line\">                ++hc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (loHead !&#x3D; null) &#123;</span><br><span class=\"line\">            if (lc &lt;&#x3D; UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">                tab[index] &#x3D; loHead.untreeify(map);</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                tab[index] &#x3D; loHead;</span><br><span class=\"line\">                if (hiHead !&#x3D; null) &#x2F;&#x2F; (else is already treeified)</span><br><span class=\"line\">                    loHead.treeify(tab);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (hiHead !&#x3D; null) &#123;</span><br><span class=\"line\">            if (hc &lt;&#x3D; UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">                tab[index + bit] &#x3D; hiHead.untreeify(map);</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                tab[index + bit] &#x3D; hiHead;</span><br><span class=\"line\">                if (loHead !&#x3D; null)</span><br><span class=\"line\">                    hiHead.treeify(tab);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class=\"line\">                                          TreeNode&lt;K,V&gt; p) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....                                      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class=\"line\">                                           TreeNode&lt;K,V&gt; p) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....                                       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,</span><br><span class=\"line\">                                               TreeNode&lt;K,V&gt; x) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>TreeNode的代码特别复杂,它使用了红黑树作为数据结构，并扩展了该数据结构。<br>\nTreeNode继承LinkedHashMap.Entry&lt;K,V&gt;.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class=\"line\">    Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        super(hash, key, value, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中扩展的数据主要使用了父类Node的next字段,TreeNode的字段prev。<br>\n以TreeNode的根节点为head，如果只使用next和prev的话，可以认为它是一个双向链表。</p>\n<h3 id=\"treeify\">treeify<a title=\"#treeify\" href=\"#treeify\"></a></h3>\n<p>节点数量大于等于8时会触发<br>\n它有个核心的方法 treeify，将只有双向链表结构的TreeNode的节点,并进行调整，转换成红黑树。大致步骤如下图:</p>\n<p><img src=\"imgs/xuyuntian/java_util/hash_tree_node.png\" alt=\"\" class=\"φcx\"></p>\n<blockquote>\n<p>这里我分别画出它prev,next,以及left,right的状态。<br>\n注意Node -&gt; TreeNode是HashTable的treeifyBin方法来转换的</p>\n</blockquote>\n<ul>\n<li>将特定位置处Node使用parent,left,right的字段来构造红黑树.</li>\n<li>观察table对应位置处的TreeNode是否为root,如果不是的话,将root移动到双向链表的首部，并引用它。</li>\n</ul>\n<h3 id=\"untreeify\">untreeify<a title=\"#untreeify\" href=\"#untreeify\"></a></h3>\n<p>节点数量不大于6时会发生</p>\n<p>从treeify的代码来看，它通过prev,next维护了一个双向链表，那么untreeify边很好理解了，只看next属性的话，我们可以认为它是一个单项链表，只需要迭代这个链表，将每个节点替换成普通的Node即可。</p>\n<h3 id=\"split\">split<a title=\"#split\" href=\"#split\"></a></h3>\n<p>当扩容发生时，会调用该方法。由于index = hash &amp; (table.length -1);所以当扩容发生时，它&amp;的比特位最高位便多了一个1,index处可能有2种变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1000000&#x2F;&#x2F;oldCap</span><br><span class=\"line\"> 111111 &#x2F;&#x2F; table.length &#x3D;&#x3D; 64,table.length -1 </span><br><span class=\"line\">1111111 &#x2F;&#x2F;table.length &#x3D;&#x3D; 128,table.length -1</span><br></pre></td></tr></table></figure>\n<p>当 (hash &amp; oldCap) == 0时，说明它的最高位为0，使用(newCap -1) &amp; hash还是处于原来的index处<br>\n当 (hash &amp; oldCap) != 0时,它的最高位为1，(newCap -1) &amp; hash == oldCap + 旧index</p>\n<blockquote>\n<p>index为某个hash值的key在table种的索引</p>\n</blockquote>\n<p>split方法将某个索引处的TreeNode归类，并分别判断它们的数量来处理treeify和untreeify的逻辑。<br>\n大致逻辑如下:</p>\n<ol>\n<li>从根节点开始迭代链表</li>\n<li>将节点归类，并产生2个新链表</li>\n<li>将新链表放到对应的位置</li>\n<li>根据链表的长度来决定treeify还是untreeify</li>\n</ol>\n<h2 id=\"get-查找一个元素\">get 查找一个元素<a title=\"#get-查找一个元素\" href=\"#get-查找一个元素\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V get(Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get代码调用了它内部的getNode方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class=\"line\">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class=\"line\">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class=\"line\">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class=\"line\">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            return first;</span><br><span class=\"line\">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class=\"line\">            if (first instanceof TreeNode)</span><br><span class=\"line\">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            do &#123;</span><br><span class=\"line\">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class=\"line\">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    return e;</span><br><span class=\"line\">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br></pre></td></tr></table></figure>\n<p>getNode的大致逻辑如下:</p>\n<ul>\n<li>使用 (table.length -1) &amp; hash 计算出index</li>\n<li>判断table[index]处的node是否是要找到的值</li>\n<li>node是否有next节点</li>\n<li>判断node的类型分别进行查找\n<ul>\n<li>TreeNode，按照红黑树的搜索逻辑进行查找</li>\n<li>Node,迭代链表</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>判断是否是要查找的节点，先判断hash，然后判断引用，最后再用key的equals方法来判断</p>\n</blockquote>\n<h2 id=\"put放入一个元素\">put放入一个元素<a title=\"#put放入一个元素\" href=\"#put放入一个元素\"></a></h2>\n<p>put可能会造成节点类型的改变，table的扩容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V put(K key, V value) &#123;</span><br><span class=\"line\">    return putVal(hash(key), key, value, false, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>put方法内部调用了putVal方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class=\"line\">               boolean evict) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class=\"line\">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class=\"line\">        n &#x3D; (tab &#x3D; resize()).length;&#x2F;&#x2F;初始化table</span><br><span class=\"line\">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class=\"line\">        tab[i] &#x3D; newNode(hash, key, value, null);&#x2F;&#x2F;对应index处的节点不存在，直接新建节点</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class=\"line\">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e &#x3D; p;&#x2F;&#x2F;找到key一样的节点</span><br><span class=\"line\">        else if (p instanceof TreeNode)</span><br><span class=\"line\">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);&#x2F;&#x2F;将节点放入红黑树中</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class=\"line\">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class=\"line\">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F;如果节点需要树化</span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class=\"line\">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                p &#x3D; e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class=\"line\">            V oldValue &#x3D; e.value;</span><br><span class=\"line\">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class=\"line\">                e.value &#x3D; value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            return oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    if (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    return null;</span><br></pre></td></tr></table></figure>\n<p>它的大致逻辑如下</p>\n<ol>\n<li>table没有初始化，进行初始化</li>\n<li>根据hash &amp; (table.length -1)计算出index</li>\n<li>判断节点的类型\n<ul>\n<li>TreeNode ,按照红黑树逻辑新增节点</li>\n<li>Node,按照链表逻辑增加节点\n<ul>\n<li>如果达到需要树化的大小，调用treeifyBin进行树化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>相同key的节点是否是已经存在？\n<ul>\n<li>用新值替换旧值并返回旧值</li>\n</ul>\n</li>\n<li>判断是否达到扩容的条件\n<ul>\n<li>扩容</li>\n</ul>\n</li>\n</ol>\n<p>这里要单独解释下扩容的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class=\"line\">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class=\"line\">    int oldThr &#x3D; threshold;</span><br><span class=\"line\">    int newCap, newThr &#x3D; 0;</span><br><span class=\"line\">    if (oldCap &gt; 0) &#123;</span><br><span class=\"line\">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class=\"line\">            return oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class=\"line\">        newCap &#x3D; oldThr;</span><br><span class=\"line\">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class=\"line\">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class=\"line\">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (int)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold &#x3D; newThr;</span><br><span class=\"line\">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class=\"line\">    table &#x3D; newTab;</span><br><span class=\"line\">    if (oldTab !&#x3D; null) &#123;</span><br><span class=\"line\">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class=\"line\">                oldTab[j] &#x3D; null;</span><br><span class=\"line\">                if (e.next &#x3D;&#x3D; null)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class=\"line\">                else if (e instanceof TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class=\"line\">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    do &#123;</span><br><span class=\"line\">                        next &#x3D; e.next;</span><br><span class=\"line\">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                            if (loTail &#x3D;&#x3D; null)</span><br><span class=\"line\">                                loHead &#x3D; e;</span><br><span class=\"line\">                            else</span><br><span class=\"line\">                                loTail.next &#x3D; e;</span><br><span class=\"line\">                            loTail &#x3D; e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        else &#123;</span><br><span class=\"line\">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class=\"line\">                                hiHead &#x3D; e;</span><br><span class=\"line\">                            else</span><br><span class=\"line\">                                hiTail.next &#x3D; e;</span><br><span class=\"line\">                            hiTail &#x3D; e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class=\"line\">                    if (loTail !&#x3D; null) &#123;</span><br><span class=\"line\">                        loTail.next &#x3D; null;</span><br><span class=\"line\">                        newTab[j] &#x3D; loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    if (hiTail !&#x3D; null) &#123;</span><br><span class=\"line\">                        hiTail.next &#x3D; null;</span><br><span class=\"line\">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>resize()的逻辑\n<ul>\n<li>oldCap (table.length)  &gt; 0 ?\n<ul>\n<li>是\n<ul>\n<li>oldCap &gt;= MAXIMUM_CAPACITY?\n<ul>\n<li>是 (这种情况并不会扩容)\n<ul>\n<li>threshold = Integer.MAX_VALUE;</li>\n<li>return table</li>\n</ul>\n</li>\n<li>否\n<ul>\n<li>newCap = oldCap &lt;&lt; 1;</li>\n<li>if newCap &lt; MAXIMUM_CAPACITY and oldCap &gt;= DEFAULT_INITIAL_CAPACITY\n<ul>\n<li>翻倍threshold (newThr = oldThr &lt;&lt; 1)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>否\n<ul>\n<li>if oldThr &gt; 0 (初始化时，指定容量的情况 threshold = tableSizeFor(initialCapacity),容量的值用threshold保存)<br>\nnewCap = oldThr</li>\n<li>else:\n<ul>\n<li>使用默认<strong>容量</strong>和默认的<strong>threshold</strong>(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY))</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>if newThr == 0 (只有newThr未被计算时触发，例如指定了初使容量时)\n<ul>\n<li>计算newThr的值,它有2种情况\n<ol>\n<li>newCap和计算后的newThr小于MAXIMUM_CAPACITY，newThr = )newCap * loadFactor;</li>\n<li>任意一个超出MAXIMUM_CAPACITY,newThr = Integer.MAX_VALUE;</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>threshold = newThr</li>\n<li>用newCap,新建table</li>\n<li>遍历旧表\n<ul>\n<li>对于一个节点的数据e\n<ul>\n<li>新的index = e.hash &amp; (newCap -1)</li>\n</ul>\n</li>\n<li>对于TreeNode\n<ul>\n<li>调用split方法，重新分布到新的table中</li>\n</ul>\n</li>\n<li>对于Node\n<ul>\n<li>遍历所有节点归类\n<ol>\n<li>e.hash &amp; (oldCap) == 0\n<ul>\n<li>分布到newTable[index]</li>\n</ul>\n</li>\n<li>e.hash &amp; (oldCap) != 0\n<ul>\n<li>分布到newTable[index + oldCap]</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>resize()的逻辑很复杂，HashMap最复杂的逻辑都在这里体现<br>\n关于节点的分类已经在TreeNode中解释过，这里不在多阐述</p>\n</blockquote>\n<h2 id=\"remove-删除一个元素\">remove 删除一个元素<a title=\"#remove-删除一个元素\" href=\"#remove-删除一个元素\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public V remove(Object key) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class=\"line\">        null : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>删除操作的内部调用了removeNode方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class=\"line\">                           boolean matchValue, boolean movable) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class=\"line\">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class=\"line\">        (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class=\"line\">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class=\"line\">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            node &#x3D; p;</span><br><span class=\"line\">        else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class=\"line\">            if (p instanceof TreeNode)</span><br><span class=\"line\">                node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                do &#123;</span><br><span class=\"line\">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class=\"line\">                        ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class=\"line\">                         (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">                        node &#x3D; e;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    p &#x3D; e;</span><br><span class=\"line\">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class=\"line\">                             (value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">            if (node instanceof TreeNode)</span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class=\"line\">            else if (node &#x3D;&#x3D; p)</span><br><span class=\"line\">                tab[index] &#x3D; node.next;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                p.next &#x3D; node.next;</span><br><span class=\"line\">            ++modCount;</span><br><span class=\"line\">            --size;</span><br><span class=\"line\">            afterNodeRemoval(node);</span><br><span class=\"line\">            return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>删除的逻辑大致如下:</p>\n<ul>\n<li>hash &amp; (table.length-1)计算出index</li>\n<li>根据index找到节点</li>\n<li>判断节点是不是需要删除的节点\n<ul>\n<li>否，根据Node类型继续查找\n<ol>\n<li>普通的Node,迭代查找</li>\n<li>TreeNode,按照红黑树逻辑进行查找</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>寻找到要查找的节点\n<ul>\n<li>根据不同的节点进行不同操作\n<ul>\n<li>TreeNode：移除TreeNode节点</li>\n<li>Node：移除普通Node节点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<blockquote>\n<ul>\n<li>有人认为，HashMap的最少容量是它的默认容量，这种说法是错误的的。从resize()的代码可以看出,当指定容量时，它的最少容量可以低于16.</li>\n<li>hash &amp; (table.length -1) 可以等价于 hash % table.length;</li>\n<li>HashMap, key的比较方式先比较hash,然后比较引用，最后再使用equal方法比较</li>\n<li>HashMap最复杂的地方在于它的TreeNode节点的处理。</li>\n</ul>\n</blockquote>\n","prev":{"title":"矩阵和","link":"2021/03/17/xuyuntian/算法相关/策略/dp_matrix"},"next":{"title":"子串匹配策略","link":"2021/03/05/xuyuntian/算法相关/策略/sub_str"},"plink":"http://example.com/2021/03/09/xuyuntian/java/hash_map/","toc":[{"id":"hashmap-源码解析","title":"HashMap 源码解析","index":"1","children":[{"id":"hashmap中node的种类","title":"HashMap中Node的种类","index":"1.1","children":[{"id":"1.-node","title":"1. Node","index":"1.1.1"},{"id":"2.-treenode","title":"2. TreeNode","index":"1.1.2"},{"id":"treeify","title":"treeify","index":"1.1.3"},{"id":"untreeify","title":"untreeify","index":"1.1.4"},{"id":"split","title":"split","index":"1.1.5"}]},{"id":"get-查找一个元素","title":"get 查找一个元素","index":"1.2"},{"id":"put放入一个元素","title":"put放入一个元素","index":"1.3"},{"id":"remove-删除一个元素","title":"remove 删除一个元素","index":"1.4"},{"id":"总结","title":"总结","index":"1.5"}]}]}