{"title":"堆","date":"2020-11-28T05:19:00.000Z","date_formatted":{"ll":"Nov 28, 2020","L":"11/28/2020","MM-DD":"11-28"},"link":"2020/11/28/xuyuntian/算法相关/树/堆","tags":["xuyuntain","二叉树","堆"],"categories":["算法"],"updated":"2020-11-28T07:03:38.290Z","content":"<h1 id=\"堆\">堆<a title=\"#堆\" href=\"#堆\"></a></h1>\n<blockquote>\n<p>堆是个数组，它近似于完全二叉树</p>\n</blockquote>\n<p>对于一个数组A的堆满足以下条件:</p>\n<ul>\n<li>对于大顶堆,除了根节点外的所有节点i满足:PARENT[i] &gt;= A[i]</li>\n<li>对于小顶堆,除了根节点外的所有节点i满足:PARENT[i] &lt;= A[i]</li>\n</ul>\n<p>堆的重要操作:</p>\n<ol>\n<li>调整</li>\n<li>…未完待续</li>\n</ol>\n<h2 id=\"调整：\">调整：<a title=\"#调整：\" href=\"#调整：\"></a></h2>\n<p>原理：对于数组A的一个节点i，假定它的左子树LEFT,和它的右子树RIGHT都为堆。通过将当前节点逐级下沉来调整，使当前节点i和LEFT,RIGHT构成的堆满足堆的条件。</p>\n<p>例子<br>\n<img src=\"imgs/xuyuntian/tree/max_heap_ajust.png\" alt=\"\"></p>\n<p>关于调整过程(大顶堆)：</p>\n<ol>\n<li>当前节点i ,对比它的左节点和它的右节点，得到值最大的节点largest。交换i，和largest</li>\n<li>当前节点设为largest,重复步骤1</li>\n</ol>\n<p>伪代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxHeapify(A,i):</span><br><span class=\"line\">    l &#x3D; left(i)</span><br><span class=\"line\">    r &#x3D; right(i)</span><br><span class=\"line\">    largest &#x3D; i</span><br><span class=\"line\">    if l &lt; A.length - 1  and A[l] &gt; A[largest]:</span><br><span class=\"line\">        largest &#x3D; l</span><br><span class=\"line\">    if r &lt; A.length - 1 and A[r] &gt; A[largest]:</span><br><span class=\"line\">        largest - r</span><br><span class=\"line\">    if (largest !&#x3D; i):</span><br><span class=\"line\">        exchange(A,largest,i)</span><br><span class=\"line\">        maxHeapify(A,largest)</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建堆\">构建堆<a title=\"#构建堆\" href=\"#构建堆\"></a></h2>\n<ol>\n<li>堆的叶子节点一定满足堆的特性。</li>\n<li>从堆的最后一个非叶子节点开始，到根节点结束。执行调整的代码</li>\n</ol>\n<p>理由：由堆的特性，自底向上构建一定能满足调整过的节点构成的树是堆。<br>\n调整顺序如下图<br>\n<img src=\"imgs/xuyuntian/tree/build_heap.png\" alt=\"\"></p>\n<p>当堆的某一层调整完成，那么上一层基于下层的所有子树，必为堆。</p>\n<p>这里我写了个demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.study.tree;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.Arrays;</span><br><span class=\"line\">import java.util.StringJoiner;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MaxHeap &#123;</span><br><span class=\"line\">    private Integer[] values;</span><br><span class=\"line\">    private int length;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MaxHeap(Integer[] array) &#123;</span><br><span class=\"line\">&#x2F;&#x2F;      构建堆</span><br><span class=\"line\">        this.length &#x3D; array.length;</span><br><span class=\"line\">&#x2F;&#x2F;        找出最后一个非叶子节点，也就是 left(i) &lt;&#x3D; length 2 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 2 * i + 1 &lt;&#x3D; length -1  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; i &#x3D;   (length - 2) &#x2F;2</span><br><span class=\"line\">        this.values &#x3D; Arrays.copyOf(array, array.length);</span><br><span class=\"line\">        for (int i &#x3D; (length - 2) &#x2F; 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class=\"line\">            maxHeapFy(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void maxHeapFy(Integer i) &#123;</span><br><span class=\"line\">&#x2F;&#x2F;        这段代码很容易写错 每次循环必须刷新root,如果使用i变量容易遗漏，所以用root存当前节点</span><br><span class=\"line\">        Integer largest &#x3D; null;</span><br><span class=\"line\">        Integer root &#x3D; i;</span><br><span class=\"line\">        Boolean exchange &#x3D; true;</span><br><span class=\"line\">        while (exchange) &#123;</span><br><span class=\"line\">            exchange &#x3D; false;</span><br><span class=\"line\">            largest &#x3D; root;</span><br><span class=\"line\">            Integer l &#x3D; left(root);</span><br><span class=\"line\">            Integer r &#x3D; right(root);</span><br><span class=\"line\">            if (l !&#x3D; null &amp;&amp; values[largest] &lt; values[l]) largest &#x3D; l;</span><br><span class=\"line\">            if (r !&#x3D; null &amp;&amp; values[largest] &lt; values[r]) largest &#x3D; r;</span><br><span class=\"line\">            if (!root.equals(largest)) &#123;</span><br><span class=\"line\">                swap(root, largest);</span><br><span class=\"line\">                exchange &#x3D; true;</span><br><span class=\"line\">                root &#x3D; largest;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Integer left(Integer i) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;        这里犯了个错误，边界值，得注意</span><br><span class=\"line\">        if (2 * i + 1 &lt;&#x3D; length - 1) return 2 * i + 1;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Integer right(Integer i) &#123;</span><br><span class=\"line\">&#x2F;&#x2F;        这里犯了个错误，边界值，得注意</span><br><span class=\"line\">        if (2 * i + 2 &lt;&#x3D; length - 1) return 2 * i + 2;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void swap(int i, int j) &#123;</span><br><span class=\"line\">        Integer temp &#x3D; values[i];</span><br><span class=\"line\">        values[i] &#x3D; values[j];</span><br><span class=\"line\">        values[j] &#x3D; temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void printArr() &#123;</span><br><span class=\"line\">        StringJoiner stringJoiner &#x3D; new StringJoiner(&quot;,&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (Integer i : values) &#123;</span><br><span class=\"line\">            stringJoiner.add(i.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(stringJoiner.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Integer[] arr &#x3D; &#123;4, 6, 2, 77, 44, 9, 7, 62, 11, 45, 66&#125;;</span><br><span class=\"line\">        MaxHeap maxHeap &#x3D; new MaxHeap(arr);</span><br><span class=\"line\">        maxHeap.printArr();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"关于堆的节点的证明:\">关于堆的节点的证明:<a title=\"#关于堆的节点的证明:\" href=\"#关于堆的节点的证明:\"></a></h2>\n<p>高度: 堆从根点到叶子节点的最短简单路径<br>\n当前节点的下标为i,设i的高度为H,H&gt;=1,它位于当前层的第k个节点,k从0开始编号</p>\n<p>那么<br>\ni = 它前面的节点数量 -1<br>\ni = 2 ^ (H) -1 + k   = 2^ H + k -1</p>\n<p>left(i) = 当前节点位置 + 当前层剩余节点树 + (当前节点前有多少个节点) * 2<br>\n= i + (2 ^ H  -(k + 1)) + (k) *2 +1 = i + (2^H + k - 1 +1) = 2 * i + 1</p>\n<p>right(i) = left(i) + 1 = 2 * i +2</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<blockquote>\n<p>《算法导论第三版》</p>\n</blockquote>\n","prev":{"title":"Java 基础知识（持续更新）","link":"2020/11/30/guyahui/BaseJava"},"next":{"title":"majunfei/test","link":"2020/11/28/majunfei/test"},"plink":"http://example.com/2020/11/28/xuyuntian/算法相关/树/堆/","toc":[{"id":"堆","title":"堆","index":"1","children":[{"id":"调整：","title":"调整：","index":"1.1"},{"id":"构建堆","title":"构建堆","index":"1.2"},{"id":"关于堆的节点的证明:","title":"关于堆的节点的证明:","index":"1.3"},{"id":"参考资料","title":"参考资料","index":"1.4"}]}]}