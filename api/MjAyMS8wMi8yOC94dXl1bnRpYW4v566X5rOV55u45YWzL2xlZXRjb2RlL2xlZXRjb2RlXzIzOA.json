{"title":"Product of Array Except Self","date":"2021-02-28T11:01:00.000Z","date_formatted":{"ll":"Feb 28, 2021","L":"02/28/2021","MM-DD":"02-28"},"link":"2021/02/28/xuyuntian/算法相关/leetcode/leetcode_238","tags":["leetcode"],"categories":["算法"],"updated":"2021-02-28T14:17:01.317Z","content":"<h1 id=\"leetcode-238:product-of-array-except-self\">leetcode 238:Product of Array Except Self<a title=\"#leetcode-238:product-of-array-except-self\" href=\"#leetcode-238:product-of-array-except-self\"></a></h1>\n<p><a href=\"https://leetcode.com/problems/product-of-array-except-self/\" target=\"_blank\">原题</a></p>\n<blockquote>\n<p>给你一个数组nums，然后输出一个新的数组，要求新数组对应index的值为nums除index之外所有元素的积。</p>\n</blockquote>\n<p>例子：</p>\n<blockquote>\n<p>Input:  [1,2,3,4]<br>\nOutput: [24,12,8,6]</p>\n</blockquote>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>这题目不难，但要注意条件。<br>\n第一次写，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class=\"line\">        long total &#x3D; 1L;</span><br><span class=\"line\">        int[] res &#x3D; new int[nums.length];</span><br><span class=\"line\">        for(int val : nums)&#123;</span><br><span class=\"line\">            total *&#x3D; (long)val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i &#x3D; 0;i&lt; nums.length;i++)&#123;</span><br><span class=\"line\">            res[i] &#x3D; (int)( total &#x2F; nums[i]); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路：</p>\n<ul>\n<li>获取nums的所有元素的积total</li>\n<li>然后索引i处的值total/i</li>\n</ul>\n<p>由于未考虑0的情况，出现Runtime Error</p>\n<p>改写代码后:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class=\"line\">        long noneZeroProduct &#x3D; 1L;</span><br><span class=\"line\">        int zeroIndex &#x3D; -1;</span><br><span class=\"line\">        int[] res &#x3D; new int[nums.length];</span><br><span class=\"line\">        for(int i &#x3D; 0;i &lt; nums.length;i++)&#123;</span><br><span class=\"line\">            if(nums[i] &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">                if(zeroIndex!&#x3D;-1)return res;</span><br><span class=\"line\">                zeroIndex &#x3D; i;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                noneZeroProduct *&#x3D; (long) nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(zeroIndex !&#x3D; -1)&#123;</span><br><span class=\"line\">            res[zeroIndex] &#x3D; (int) noneZeroProduct;</span><br><span class=\"line\">            return res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i &#x3D; 0;i&lt; nums.length;i++)&#123;</span><br><span class=\"line\">            res[i] &#x3D; (int)( noneZeroProduct &#x2F; nums[i]); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次考虑0的情况:</p>\n<ul>\n<li>存在2个元素为0时，直接返回默认值全为0的数组</li>\n<li>存在一个0的情况，zeroIndex处的值为其元素的累积</li>\n<li>不存0，结果为 所有元素的累积/当前索引处的值</li>\n</ul>\n<h2 id=\"runtime-1ms的思路\">Runtime 1ms的思路<a title=\"#runtime-1ms的思路\" href=\"#runtime-1ms的思路\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class=\"line\">        int[] res &#x3D; new int[nums.length];</span><br><span class=\"line\">        </span><br><span class=\"line\">        int prodSoFar &#x3D; 1;</span><br><span class=\"line\">        res[0] &#x3D; 1;</span><br><span class=\"line\">        for (int index &#x3D; 1; index &lt; nums.length; index++) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;从左向右边扫描，并记录res[i] &#x3D; 1 or res[0] * res[1] *...res[i-1]</span><br><span class=\"line\">            res[index] +&#x3D; prodSoFar * nums [index - 1];</span><br><span class=\"line\">            prodSoFar &#x3D; res[index];        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        prodSoFar &#x3D; 1;</span><br><span class=\"line\">        for (int index &#x3D; nums.length - 2; index &gt;&#x3D; 0; index--) &#123;</span><br><span class=\"line\">            res[index] *&#x3D; (prodSoFar * nums [index + 1]);</span><br><span class=\"line\">            prodSoFar &#x3D; prodSoFar * nums [index + 1];&#x2F;&#x2F;从右向左扫描 用 prodSoFar记录 右边到左边的累积</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从左向右扫描，记录累积</li>\n<li>从右向左扫描记录累积</li>\n<li>合并累积</li>\n</ul>\n<p>具体原理见下图<br>\n<img src=\"imgs%5Cxuyuntian%5Cleetcode%5Cleetcode238_1.png\" alt=\"\"></p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<blockquote>\n<p>双向扫描这个思路，第一次见。刚开始也没看明白别人的思路。<br>\n处理这种对于迭代结果排除自身的问题，可以考虑这种思路。</p>\n</blockquote>\n","next":{"title":"Java AQS CountDownLatch","link":"2021/02/26/xuyuntian/java/io_and_thread/aqs_cl"},"plink":"http://example.com/2021/02/28/xuyuntian/算法相关/leetcode/leetcode_238/","toc":[{"id":"leetcode-238:product-of-array-except-self","title":"leetcode 238:Product of Array Except Self","index":"1","children":[{"id":"个人思路","title":"个人思路","index":"1.1"},{"id":"runtime-1ms的思路","title":"Runtime 1ms的思路","index":"1.2"},{"id":"总结","title":"总结","index":"1.3"}]}]}