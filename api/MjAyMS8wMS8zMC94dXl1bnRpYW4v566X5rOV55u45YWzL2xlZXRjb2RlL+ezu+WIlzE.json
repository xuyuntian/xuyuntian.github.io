{"title":"算法攻略-1","date":"2021-01-30T07:15:00.000Z","date_formatted":{"ll":"Jan 30, 2021","L":"01/30/2021","MM-DD":"01-30"},"link":"2021/01/30/xuyuntian/算法相关/leetcode/系列1","tags":["leetcode"],"categories":["算法"],"updated":"2021-01-30T11:48:40.869Z","content":"<h1 id=\"方法\">方法<a title=\"#方法\" href=\"#方法\"></a></h1>\n<p>光努力是没有用的，努力是最廉价的要讲究方法策略</p>\n<ol>\n<li>\n<p>当你某道题不会的时候，你也许会在讨论区看别人的代码，看完别人的代码你可能会有所收获：哦原来这样也可以啊。但是，你回过头来，不参考别人代码自己写的时候，却发现自己写不出来。<strong>这说明你自己根本没明白别人的思路为什么是正确的</strong>这种情况<br>\n你要反复推敲别人的思路，不断在脑中按照各种情况来验证。</p>\n</li>\n<li>\n<p><strong>做题之前到底要不要自己苦思冥想</strong> 思考是非常重要的，但是当你的认知在某个范围之类，你无论怎么思考都是没有效果的。除非你的思考范围突破了你当前的认识（基本是不可能的）。我们可以进行<em>选择性</em><strong>死磕</strong>。比如说，刷10题，只死磕一道。但是当你完全没有思路时，一定要及时放弃，不然完全在浪时间。</p>\n</li>\n<li>\n<p><strong>如何判断自己的思路是正确的</strong> 这其实很难。更多的是总结经验，通常是进行情况分析，在不同状态的变化中能维持它的正确性。</p>\n</li>\n<li>\n<p><strong>强化</strong>。 不要认为你做过相同得题目你就能再次轻易地将它搞定。有时候相同地题有很多中解法，你要尝试用不同策略来搞定它。</p>\n</li>\n<li>\n<p><strong>逻辑</strong> 以上4个点总结来看就是逻辑了。逻辑需要不断通过以上4点来强化。</p>\n</li>\n</ol>\n<h1 id=\"简单题\">简单题<a title=\"#简单题\" href=\"#简单题\"></a></h1>\n<p><strong>简单题都是些简单的逻辑</strong>但是，有的题目真的挺考验逻辑的</p>\n<h2 id=\"1299.-replace-elements-with-greatest-element-on-right-side\">1299. Replace Elements with Greatest Element on Right Side<a title=\"#1299.-replace-elements-with-greatest-element-on-right-side\" href=\"#1299.-replace-elements-with-greatest-element-on-right-side\"></a></h2>\n<p><a href=\"https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/\" target=\"_blank\">原题</a></p>\n<p>给你一个int数组，对所有元素用它右侧最大地数来替换它，如果右侧没有则用-1来替换<br>\n例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr &#x3D; [17,18,5,4,6,1] &#x2F;&#x2F;原数组</span><br><span class=\"line\">RES &#x3D; [18,6,6,6,1,-1] &#x2F;&#x2F;替换后地值</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;数据的范围</span><br><span class=\"line\">1 &lt;&#x3D; arr.length &lt;&#x3D; 104</span><br><span class=\"line\">1 &lt;&#x3D; arr[i] &lt;&#x3D; 105</span><br></pre></td></tr></table></figure>\n<ul>\n<li>我第一次看到这道题的时候使用了优先队列</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] replaceElements(int[] arr) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;Integer&gt; q &#x3D; new PriorityQueue&lt;&gt;((a,b)-&gt; b-a);</span><br><span class=\"line\">        for(int val : arr)&#123;</span><br><span class=\"line\">            q.add(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i &#x3D; 0 ;i &lt; arr.length -1;i++)&#123;</span><br><span class=\"line\">            q.remove(arr[i]);</span><br><span class=\"line\">            arr[i] &#x3D; q.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[arr.length-1] &#x3D; -1;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用优先队列来维护所有元素，然后重新循环这个数组（排除最后一个元素），将该元素从优先队列移除。然后将这个位置的数赋值为优先队列顶部的最大值。<br>\n这个时间复杂度其实是O(N*N);优先队列的移除操作就是直接暴力搜索整个队列，找到第一个值相同的元素将它删除。</p>\n<ul>\n<li>如果使用TreeMap 来记录某个元素的数量也是没问题的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] replaceElements(int[] arr) &#123;</span><br><span class=\"line\">        TreeMap&lt;Integer,Integer&gt; counter &#x3D; new TreeMap&lt;&gt;((a,b) -&gt; b -a);</span><br><span class=\"line\">        for(int val : arr)&#123;</span><br><span class=\"line\">            counter.put(val,counter.getOrDefault(val,0)+1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i &#x3D; 0 ;i &lt; arr.length;i++)&#123;</span><br><span class=\"line\">            int cur &#x3D; arr[i];</span><br><span class=\"line\">            int c &#x3D; counter.get(cur);</span><br><span class=\"line\">            if(c &#x3D;&#x3D; 1) counter.remove(cur);</span><br><span class=\"line\">            else counter.put(cur,c-1);</span><br><span class=\"line\">            Integer rightMax &#x3D; -1;</span><br><span class=\"line\">            if(counter.size() &gt; 0) rightMax &#x3D; counter.firstKey();</span><br><span class=\"line\">            arr[i] &#x3D; rightMax;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种解法时间复杂度是N * lgN;</p>\n<ul>\n<li><strong>最优解</strong> (其他人优秀的思路) 从右到左维护一个最大值，然后不断更新它</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] replaceElements(int[] arr) &#123;</span><br><span class=\"line\">        int max &#x3D; -1;</span><br><span class=\"line\">        for(int i &#x3D; arr.length -1;i &gt;&#x3D; 0;i--)&#123;</span><br><span class=\"line\">            int curMax &#x3D; max;</span><br><span class=\"line\">            max &#x3D; Math.max(arr[i],max);</span><br><span class=\"line\">            arr[i] &#x3D; curMax;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"1002.-find-common-characters\">1002. Find Common Characters<a title=\"#1002.-find-common-characters\" href=\"#1002.-find-common-characters\"></a></h1>\n<p><a href=\"https://leetcode.com/problems/find-common-characters/\" target=\"_blank\">原题</a></p>\n<p>给你一个字符串列表，找出他们共有的相同字符(可以重复)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class=\"line\">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">1. 1 &lt;&#x3D; A.length &lt;&#x3D; 100</span><br><span class=\"line\">2. 1 &lt;&#x3D; A[i].length &lt;&#x3D; 100</span><br><span class=\"line\">3. A[i][j] is a lowercase letter</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这题其实毫无难度其实也就用到了 <strong>Map</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;String&gt; commonChars(String[] A) &#123;</span><br><span class=\"line\">        int[][] map &#x3D; new int[A.length][26];</span><br><span class=\"line\">        for(int i &#x3D; 0;i &lt; A.length;i++)&#123;</span><br><span class=\"line\">            char[] arr &#x3D; A[i].toCharArray();</span><br><span class=\"line\">            for(char val : arr)&#123;</span><br><span class=\"line\">                map[i][val-&#39;a&#39;]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;String&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for(int i &#x3D; 0;i &lt; 26;i++)&#123;</span><br><span class=\"line\">            int min &#x3D; Integer.MAX_VALUE;</span><br><span class=\"line\">            for(int j &#x3D; 0; j &lt; A.length;j++)&#123;</span><br><span class=\"line\">                min &#x3D; Math.min(min,map[j][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(int n &#x3D; 0;n &lt; min ;n++)&#123;</span><br><span class=\"line\">                &#x2F;&#x2F;这里要注意 </span><br><span class=\"line\">                res.add(String.valueOf((char)(i+&#39;a&#39;)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>统计每个字符串拥有字符数</li>\n<li>遍历字符a-z,然后计算每个字符串中字符的最小值</li>\n</ol>\n<h1 id=\"237.-delete-node-in-a-linked-list\">237. Delete Node in a Linked List<a title=\"#237.-delete-node-in-a-linked-list\" href=\"#237.-delete-node-in-a-linked-list\"></a></h1>\n<p><a href=\"https://leetcode.com/problems/delete-node-in-a-linked-list/\" target=\"_blank\">原题</a></p>\n<p>给你一个链表中的节点，要求删除该链表中的该节点(给出的节点不是最后一个节点)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如对于 4-&gt;3-&gt;2-&gt;1</span><br><span class=\"line\">给你节点3</span><br><span class=\"line\">结果为 4-&gt;2-&gt;1</span><br></pre></td></tr></table></figure>\n<p>当我第一眼看到这题时我也有点蒙，因为只给你当前节点，我们是无法得到它的前一个节点的。但是，如果得到的值与删除之后一致便可以得到与删除该节点一样的值。题目中给出的条件是节点不可能是最后一个节点，那么我们可以<strong>将当前节点的值赋为它的下个节点</strong>,并将它的下个节点指向它的下下个节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public void deleteNode(ListNode node) &#123;</span><br><span class=\"line\">        node.val &#x3D; node.next.val;</span><br><span class=\"line\">        node.next &#x3D; node.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>未完待续…</p>\n</blockquote>\n","prev":{"title":"二分查找","link":"2021/01/30/xuyuntian/算法相关/策略/二分查找"},"next":{"title":"简介","link":"2021/01/30/简介"},"plink":"http://example.com/2021/01/30/xuyuntian/算法相关/leetcode/系列1/","toc":[{"id":"方法","title":"方法","index":"1"},{"id":"简单题","title":"简单题","index":"2","children":[{"id":"1299.-replace-elements-with-greatest-element-on-right-side","title":"1299. Replace Elements with Greatest Element on Right Side","index":"2.1"}]},{"id":"1002.-find-common-characters","title":"1002. Find Common Characters","index":"3"},{"id":"237.-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","index":"4"}]}