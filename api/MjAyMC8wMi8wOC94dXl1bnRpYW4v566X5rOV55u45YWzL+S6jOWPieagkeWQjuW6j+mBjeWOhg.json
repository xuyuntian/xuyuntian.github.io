{"title":"二叉树后序遍历","date":"2020-02-08T13:25:00.000Z","date_formatted":{"ll":"Feb 8, 2020","L":"02/08/2020","MM-DD":"02-08"},"link":"2020/02/08/xuyuntian/算法相关/二叉树后序遍历","tags":["二叉树"],"categories":["算法"],"updated":"2021-01-30T06:44:08.113Z","content":"<h3 id=\"二叉树后序遍历\">二叉树后序遍历<a title=\"#二叉树后序遍历\" href=\"#二叉树后序遍历\"></a></h3>\n<p><a href=\"https://leetcode.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\">原题</a></p>\n<p><img src=\"imgs/xuyuntian/test.jpeg\" alt=\"\" class=\"φcx\"></p>\n<p>后序遍历如果用递归写法并不难，但一旦使用栈，就很难解决。</p>\n<p>要想使用栈得对当前节点进行分析：</p>\n<ol>\n<li>当前节点是否有子节点</li>\n<li>当前节点的子节点是否被访问到。</li>\n<li>后序遍历按照左子树 -&gt; 右子树 -&gt; 根节点的次序</li>\n</ol>\n<p>所以，只有当有 <em><strong>子节点被访问,才有可能访问根节点</strong></em><br>\n能访问当前节点存在3种情况</p>\n<ol>\n<li>上次访问过的节点为当前节点的右子节点</li>\n<li>上次访问过的节点为当前节点的左子节点，且当前节点的右子节点为空</li>\n<li>当前节点为叶子节点</li>\n</ol>\n<p>以节点为思路代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * public class TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode left;</span><br><span class=\"line\"> *     TreeNode right;</span><br><span class=\"line\"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        TreeNode preVisited &#x3D; null;</span><br><span class=\"line\">        TreeNode cur &#x3D; root;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class=\"line\">        while( cur!&#x3D;null || stack.size() &gt; 0)&#123;</span><br><span class=\"line\">            if(cur!&#x3D;null)&#123;</span><br><span class=\"line\">                if(preVisited !&#x3D;null)&#123;</span><br><span class=\"line\">                    if(preVisited &#x3D;&#x3D; cur.left)&#123;</span><br><span class=\"line\">                        if(cur.right !&#x3D; null)&#123;</span><br><span class=\"line\">                            stack.push(cur);</span><br><span class=\"line\">                            cur &#x3D; cur.right;</span><br><span class=\"line\">                        &#125;else&#123;</span><br><span class=\"line\">                            res.add(cur.val);</span><br><span class=\"line\">                            preVisited &#x3D; cur;</span><br><span class=\"line\">                            cur &#x3D; stack.size() &gt; 0 ? stack.pop():null;                     </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        continue;</span><br><span class=\"line\">                    &#125;else if(preVisited &#x3D;&#x3D; cur.right)&#123;</span><br><span class=\"line\">                        &#x2F;&#x2F;访问当前节点。</span><br><span class=\"line\">                        res.add(cur.val);</span><br><span class=\"line\">                        preVisited &#x3D; cur;</span><br><span class=\"line\">                        cur &#x3D; stack.size() &gt; 0 ? stack.pop():null;</span><br><span class=\"line\">                        continue;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(cur.left!&#x3D;null)&#123;</span><br><span class=\"line\">                    stack.push(cur);</span><br><span class=\"line\">                    cur &#x3D; cur.left;</span><br><span class=\"line\">                &#125;else if(cur.right!&#x3D;null)&#123;</span><br><span class=\"line\">                    stack.push(cur);</span><br><span class=\"line\">                    cur &#x3D; cur.right;</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    res.add(cur.val);</span><br><span class=\"line\">                    preVisited &#x3D; cur;</span><br><span class=\"line\">                    cur &#x3D; stack.size() &gt; 0 ? stack.pop():null;                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                cur &#x3D; stack.size() &gt; 0 ? stack.pop():null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以是否能够入栈为思路的代码如下。与上面相反，当节点不能被访问时，便可以入栈。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * public class TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode left;</span><br><span class=\"line\"> *     TreeNode right;</span><br><span class=\"line\"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        TreeNode pointer &#x3D; root;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; s &#x3D; new Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode preVisited &#x3D; null;</span><br><span class=\"line\">        while(pointer!&#x3D;null || !s.empty())&#123;</span><br><span class=\"line\">            while(pointer.left !&#x3D; null&amp;&amp;preVisited!&#x3D; pointer.left &amp;&amp;(preVisited&#x3D;&#x3D;null||preVisited!&#x3D;pointer.right))&#123;</span><br><span class=\"line\">                s.push(pointer);</span><br><span class=\"line\">                pointer &#x3D; pointer.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(pointer.right!&#x3D;null &amp;&amp; preVisited!&#x3D;pointer.right)&#123;</span><br><span class=\"line\">                s.push(pointer);</span><br><span class=\"line\">                pointer &#x3D; pointer.right;</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                res.add(pointer.val);</span><br><span class=\"line\">                preVisited &#x3D; pointer;</span><br><span class=\"line\">                if(!s.empty())&#123;</span><br><span class=\"line\">                    pointer &#x3D; s.pop();</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    pointer &#x3D; null;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这2段代码相差7个半月<br>\n第一段代码就是这篇文章发布那天时写的，<br>\n有时候解决问题的出发点不同，代码差别还是挺大的</p>\n</blockquote>\n","prev":{"title":"简介","link":"2020/11/24/简介"},"plink":"http://example.com/2020/02/08/xuyuntian/算法相关/二叉树后序遍历/","toc":[{"id":"二叉树后序遍历","title":"二叉树后序遍历","index":"1"}]}