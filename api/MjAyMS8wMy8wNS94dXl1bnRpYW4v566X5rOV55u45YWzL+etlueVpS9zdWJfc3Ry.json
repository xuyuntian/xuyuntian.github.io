{"title":"子串匹配策略","date":"2021-03-05T10:22:00.000Z","date_formatted":{"ll":"Mar 5, 2021","L":"03/05/2021","MM-DD":"03-05"},"link":"2021/03/05/xuyuntian/算法相关/策略/sub_str","tags":["双指针","字符串"],"categories":["算法"],"updated":"2021-03-05T02:38:26.273Z","content":"<h1 id=\"子串匹配策略\">子串匹配策略<a title=\"#子串匹配策略\" href=\"#子串匹配策略\"></a></h1>\n<h2 id=\"场景\">场景<a title=\"#场景\" href=\"#场景\"></a></h2>\n<p>给你一个字符串s,和一个目标字符串target,要求删除s中任意个字符，最终能否得到一个新的子串值和target一样?</p>\n<p><strong>这种情况下，爆破完全不可取</strong></p>\n<p>有种通用的解法<strong>双指针</strong></p>\n<ul>\n<li>维护指针i,j</li>\n<li>i对应s的下标，j对应target的下标</li>\n<li>当s[i] == target[j] 同时移动i和j否则只移动i</li>\n<li>观察最终j是否越界</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean isSubSeq(String s,String target)&#123;</span><br><span class=\"line\">    int i &#x3D; 0,j &#x3D; 0;</span><br><span class=\"line\">    while(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class=\"line\">        if(s.charAt(i) &#x3D;&#x3D; target.charAt(j))j++;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return j &#x3D;&#x3D; target.length();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有种变形的写法，用indexOf方法来替代直接比较，能减少charAt(j)的调用次数，稍微提高性能，本质上区别不大</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean isSubSeq(String s,String target)&#123;</span><br><span class=\"line\">    int i &#x3D; 0,j &#x3D; 0;</span><br><span class=\"line\">    while(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class=\"line\">        int mI &#x3D; s.indexOf(target.charAt(j),i);</span><br><span class=\"line\">        if (mI &#x3D;&#x3D; -1) return false;</span><br><span class=\"line\">        i &#x3D; mI + 1;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return j &#x3D;&#x3D; target.length();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"相关题目\">相关题目<a title=\"#相关题目\" href=\"#相关题目\"></a></h2>\n<blockquote>\n<p><a href=\"https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/\" target=\"_blank\">Longest Word in Dictionary through Deleting</a></p>\n</blockquote>\n","next":{"title":"反转链表","link":"2021/03/04/xuyuntian/算法相关/策略/reverse_list"},"plink":"http://example.com/2021/03/05/xuyuntian/算法相关/策略/sub_str/","toc":[{"id":"子串匹配策略","title":"子串匹配策略","index":"1","children":[{"id":"场景","title":"场景","index":"1.1"},{"id":"相关题目","title":"相关题目","index":"1.2"}]}]}