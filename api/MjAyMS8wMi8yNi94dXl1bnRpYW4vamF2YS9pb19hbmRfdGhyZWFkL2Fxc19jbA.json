{"title":"Java AQS CountDownLatch","date":"2021-02-26T11:30:01.000Z","date_formatted":{"ll":"Feb 26, 2021","L":"02/26/2021","MM-DD":"02-26"},"link":"2021/02/26/xuyuntian/java/io_and_thread/aqs_cl","tags":["基础知识","线程"],"categories":["java"],"updated":"2021-02-28T14:11:18.392Z","content":"<h1 id=\"java-aqs-countdownlatch\">Java AQS CountDownLatch<a title=\"#java-aqs-countdownlatch\" href=\"#java-aqs-countdownlatch\"></a></h1>\n<p>CountDownLatch是一个计数器，它能够根据计数器里面的数量来控制线程。</p>\n<p>参考以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CountDownLatch countDownLatch &#x3D; new CountDownLatch(2);</span><br><span class=\"line\">Runnable r1 &#x3D; () -&gt; &#123;</span><br><span class=\"line\">    System.out.println(&quot;---降低计数器&quot;);</span><br><span class=\"line\">    countDownLatch.countDown();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Runnable r2 &#x3D;() -&gt; &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;执行&quot;+i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">new Thread(r1,&quot;只执行countDown1&quot;).start();</span><br><span class=\"line\">new Thread(r1,&quot;只执行countDown2&quot;).start();</span><br><span class=\"line\">for(char i &#x3D; &#39;a&#39;;i &lt; &#39;z&#39;;i++)&#123;</span><br><span class=\"line\">    new Thread(r2,&quot;执行await和countDown-&quot;+i).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果有多种，但是只有执行countDown()方法的线程都执行它之后(计数器为0)，后续的线程才能执行。</p>\n<ul>\n<li>countDown()让计数器的值减去1（计数器为0不操作）</li>\n<li>await() 计数器不为0，则挂起线程加入队列，为0直接返回</li>\n</ul>\n<h2 id=\"countdownlatch的结构\">CountDownLatch的结构<a title=\"#countdownlatch的结构\" href=\"#countdownlatch的结构\"></a></h2>\n<p><img src=\"imgs/xuyuntian/thread/aqs/aqs_cl.png\" alt=\"\"><br>\n<img src=\"imgs/xuyuntian/thread/aqs/aqs_cl_sync.png\" alt=\"\"><br>\n<img src=\"imgs/xuyuntian/thread/aqs/aqs_cl_sync_ex.png\" alt=\"\"></p>\n<p>CountDownLatch有个字段sync，该字段的类型为Sync是它的一个静态内部类。<br>\nSync继承类aqs,并重写了tryAcquireShared和tryReleaseShared</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected int tryAcquireShared(int acquires) &#123;</span><br><span class=\"line\">    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        int c &#x3D; getState();</span><br><span class=\"line\">        if (c &#x3D;&#x3D; 0)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        int nextc &#x3D; c-1;</span><br><span class=\"line\">        if (compareAndSetState(c, nextc))</span><br><span class=\"line\">            return nextc &#x3D;&#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会发现tryAcquireShared并没有增加state的值，只是作了state是不是为0的判断<br>\ntryReleaseShared,只是尝试减少state的值，如果state为0，直接返回false;<br>\n下面分析countDown()和await()方法</p>\n<h3 id=\"countdown()\">countDown()<a title=\"#countdown()\" href=\"#countdown()\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void countDown() &#123;</span><br><span class=\"line\">    sync.releaseShared(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到它调用了Sync类的releaseShared方法（继承于aqs）,tryReleaseShared会降低state的值(state&gt;0)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean releaseShared(int arg) &#123;</span><br><span class=\"line\">    if (tryReleaseShared(arg)) &#123;&#x2F;&#x2F;如果为0返回true,执行doReleaseShared方法</span><br><span class=\"line\">        doReleaseShared();&#x2F;&#x2F;唤醒队列中的线程</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于aqs会根据tryReleaseShared方法的返回值来判断是否唤醒队列中等待的线程(这里不再讨论aqs的细节)。<br>\nstate为0，返回true,aqs唤醒所有排队线程。</p>\n<h3 id=\"await()\">await()<a title=\"#await()\" href=\"#await()\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void await() throws InterruptedException &#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sync中的acquireSharedInterruptibly来自于aqs。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireSharedInterruptibly(int arg)</span><br><span class=\"line\">        throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();</span><br><span class=\"line\">    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;state不为 0 返回 -1，执行doAcquireSharedInterruptibly</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当state不为0的时候会执行doAcquireSharedInterruptibly,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doAcquireSharedInterruptibly(int arg)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class=\"line\">    boolean failed &#x3D; true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p &#x3D; node.predecessor();</span><br><span class=\"line\">            if (p &#x3D;&#x3D; head) &#123;&#x2F;&#x2F;这种情况下会再次尝试</span><br><span class=\"line\">                int r &#x3D; tryAcquireShared(arg);</span><br><span class=\"line\">                if (r &gt;&#x3D; 0) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class=\"line\">                    failed &#x3D; false;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F;先标记，再次获取锁失败挂起</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                throw new InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>doAcquireSharedInterruptibly里面有个循环。正常情况下,当前节点不是队列中第一个节点，所以先执行shouldParkAfterFailedAcquire进行标记，然后再次进入循环体执行parkAndCheckInterrupt挂起线程。</p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>分析了CountDownLatch的结构之后,得出以下结论。</p>\n<ul>\n<li>CountDownLatch的计数器一旦为0，计数器便不能再改变</li>\n<li>可以允许多个线程同时等待计数器为0</li>\n<li>计数器为0后，所有执行await()方法的线程互不干扰。</li>\n</ul>\n","prev":{"title":"Product of Array Except Self","link":"2021/02/28/xuyuntian/算法相关/leetcode/leetcode_238"},"next":{"title":"Java AQS 之条件队列","link":"2021/02/25/xuyuntian/java/io_and_thread/aqs_c"},"plink":"http://example.com/2021/02/26/xuyuntian/java/io_and_thread/aqs_cl/","toc":[{"id":"java-aqs-countdownlatch","title":"Java AQS CountDownLatch","index":"1","children":[{"id":"countdownlatch的结构","title":"CountDownLatch的结构","index":"1.1","children":[{"id":"countdown()","title":"countDown()","index":"1.1.1"},{"id":"await()","title":"await()","index":"1.1.2"}]},{"id":"总结","title":"总结","index":"1.2"}]}]}