{"title":"Java AQS 之排它锁","date":"2021-02-23T08:30:01.000Z","date_formatted":{"ll":"Feb 23, 2021","L":"02/23/2021","MM-DD":"02-23"},"link":"2021/02/23/xuyuntian/java/io_and_thread/aqs_e","tags":["基础知识","线程"],"categories":["java"],"updated":"2021-02-26T06:28:48.132Z","content":"<h1 id=\"java-aqs-之排它锁\">Java AQS 之排它锁<a title=\"#java-aqs-之排它锁\" href=\"#java-aqs-之排它锁\"></a></h1>\n<p>AbstractQueuedSynchronizer简称（aqs)是一个抽象类，提供了对锁的操作。只要重写它以下的方法便很容易<br>\n实现锁的基本功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">     throw new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean tryRelease(int arg) &#123;</span><br><span class=\"line\">    throw new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected int tryAcquireShared(int arg) &#123;</span><br><span class=\"line\">    throw new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class=\"line\">    throw new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean isHeldExclusively() &#123;</span><br><span class=\"line\">    throw new UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从reentrantlock出发\">从ReentrantLock出发<a title=\"#从reentrantlock出发\" href=\"#从reentrantlock出发\"></a></h2>\n<p>参考以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock l &#x3D; new ReentrantLock();</span><br><span class=\"line\">Runnable runnable &#x3D; () -&gt; &#123;</span><br><span class=\"line\">    l.lock();</span><br><span class=\"line\">    for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + &quot;:step&quot;+i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l.unlock();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">for(int i &#x3D; 1;i &lt;&#x3D; 20;i++)&#123;</span><br><span class=\"line\">    new Thread(runnable,&quot;线程-&quot;+i).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行的结果有很多种，但是，当一个线程获取锁，所有其他线程全部被阻塞。</li>\n<li>这种锁为排它锁</li>\n</ul>\n<p>接下来将会讲解它是如何实现的</p>\n<p>ReentrantLock 它只有一个最核心的字段</p>\n<blockquote>\n<p>private final Sync sync;</p>\n</blockquote>\n<p>它有3个静态内部类</p>\n<ul>\n<li>Sync (抽象类)</li>\n<li>NonfairSync (非公平锁)</li>\n<li>FairSync (公平锁)</li>\n</ul>\n<p>他们的继承关系如下<br>\n<img src=\"imgs/xuyuntian/thread/aqs/syc_in_reentrant_lock.png\" alt=\"\"></p>\n<p>从ReentrantLock的lock方法开始,它调用了它字段sync的lock方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void lock() &#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而sync的lock方法是个抽象方法</p>\n<blockquote>\n<p>abstract void lock()</p>\n</blockquote>\n<p>它的子类<strong>NonfairSync</strong>和<strong>FairSync</strong>实现了该方法<br>\n从ReentrantLock的构造方法看，默认情况下，它使用的是非公平锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ReentrantLock() &#123;</span><br><span class=\"line\">    sync &#x3D; new NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public ReentrantLock(boolean fair) &#123;</span><br><span class=\"line\">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1.从非公平锁出发来深入了解它的实现\">1.从<em>非公平锁</em>出发来深入了解它的实现<a title=\"#1.从非公平锁出发来深入了解它的实现\" href=\"#1.从非公平锁出发来深入了解它的实现\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class NonfairSync extends Sync &#123;</span><br><span class=\"line\">    private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class=\"line\">    final void lock() &#123;</span><br><span class=\"line\">        if (compareAndSetState(0, 1))&#x2F;&#x2F;cas尝试获取state</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        else</span><br><span class=\"line\">            acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class=\"line\">        return nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NonfairSync 继承了Sync并重写了2个方法 lock和tryAcquire，其中lock方法属于Sync,而tryAcquire属于AbstractQueuedSynchronizer。</p>\n<p>继续从lock出发，第一步它尝试使用cas 来尝试获取state，如果失败了进入acquire方法。<br>\nacquire属于AbstractQueuedSynchronizer，它的目的是为了重试获取锁。如果失败线程会被挂起。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquire(int arg) &#123;</span><br><span class=\"line\">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>acquire方法内部先尝试调用tryAcquire，如果失败会调用acquireQueued方法，在调用acquireQueued前会将当前线程加入队列。</p>\n</blockquote>\n<p>先忽略其他方法，单独观察tryAcquire方法。它实际上调用了Sync的nonfairTryAcquire方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class=\"line\">    final Thread current &#x3D; Thread.currentThread();</span><br><span class=\"line\">    int c &#x3D; getState();</span><br><span class=\"line\">    if (c &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;cas抢锁</span><br><span class=\"line\">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);&#x2F;&#x2F;设置当前占有锁的线程</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;&#x2F;&#x2F;重入锁</span><br><span class=\"line\">        int nextc &#x3D; c + acquires;</span><br><span class=\"line\">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>nonfairTryAcquire会进行以下操作:</p>\n<ol>\n<li>state为0，使用cas设置state的值,成功返回true</li>\n<li>state不为0，查看当前线程是否是占有锁的线程，是，增加state的值,并返回true</li>\n<li>其他情况返回fasle</li>\n</ol>\n<p>下面从AbstractQueuedSynchronizer的结构出发，来继续了解acquireQueued,和addWaiter方法。</p>\n<h2 id=\"abstractqueuedsynchronizer\">AbstractQueuedSynchronizer<a title=\"#abstractqueuedsynchronizer\" href=\"#abstractqueuedsynchronizer\"></a></h2>\n<h3 id=\"aqs的字段\">aqs的字段<a title=\"#aqs的字段\" href=\"#aqs的字段\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private transient volatile Node head;&#x2F;&#x2F;队列的头</span><br><span class=\"line\">private transient volatile Node tail;&#x2F;&#x2F;队列的尾</span><br><span class=\"line\">private volatile int state;&#x2F;&#x2F;队列的状态</span><br></pre></td></tr></table></figure>\n<p>AbstractQueuedSynchronizer继承AbstractOwnableSynchronizer，占有锁的当前线程字段exclusiveOwnerThread在类AbstractOwnableSynchronizer中</p>\n<blockquote>\n<p>private transient Thread exclusiveOwnerThread;</p>\n</blockquote>\n<h3 id=\"node\">Node<a title=\"#node\" href=\"#node\"></a></h3>\n<p>AbstractQueuedSynchronizer有个静态内部类 Node,这个类有以下常量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final Node SHARED &#x3D; new Node();&#x2F;&#x2F;代表结点是共享的</span><br><span class=\"line\">static final Node EXCLUSIVE &#x3D; null;&#x2F;&#x2F; 代表结点是排它的</span><br><span class=\"line\">static final int CANCELLED &#x3D;  1;&#x2F;&#x2F;线程被取消</span><br><span class=\"line\">static final int SIGNAL    &#x3D; -1;&#x2F;&#x2F;线程位于队列中</span><br><span class=\"line\">static final int CONDITION &#x3D; -2;&#x2F;&#x2F;线程位于条件队列中</span><br><span class=\"line\">static final int PROPAGATE &#x3D; -3;&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>\n<p>它的字段如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">volatile int waitStatus;&#x2F;&#x2F;结点中线程的状态,默认为0</span><br><span class=\"line\">volatile Node prev;&#x2F;&#x2F;前驱结点</span><br><span class=\"line\">volatile Node next;&#x2F;&#x2F;后继结点</span><br><span class=\"line\">volatile Thread thread;&#x2F;&#x2F;线程</span><br><span class=\"line\">Node nextWaiter;&#x2F;&#x2F;可以用于代表线程持有锁的类型，也可以表示condition队列中结点的下个结点。</span><br></pre></td></tr></table></figure>\n<p>它有以下方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;判断结点是否是共享锁的结点</span><br><span class=\"line\">final boolean isShared() &#123;</span><br><span class=\"line\">    return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;返回结点的前驱结点</span><br><span class=\"line\">final Node predecessor() throws NullPointerException &#123;</span><br><span class=\"line\">    Node p &#x3D; prev;</span><br><span class=\"line\">    if (p &#x3D;&#x3D; null)</span><br><span class=\"line\">        throw new NullPointerException();</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"addwaiter方法\">addWaiter方法<a title=\"#addwaiter方法\" href=\"#addwaiter方法\"></a></h3>\n<p>现在回到addWaiter方法，addWaiter方法目的是为了向队列中添加结点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Node addWaiter(Node mode) &#123;</span><br><span class=\"line\">    Node node &#x3D; new Node(Thread.currentThread(), mode);&#x2F;&#x2F;以当前线程初始化结点</span><br><span class=\"line\">    Node pred &#x3D; tail;</span><br><span class=\"line\">    if (pred !&#x3D; null) &#123;&#x2F;&#x2F;前驱不为空</span><br><span class=\"line\">        node.prev &#x3D; pred;</span><br><span class=\"line\">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next &#x3D; node;</span><br><span class=\"line\">            return node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);&#x2F;&#x2F;第一次cas设置tail失败，或者前驱结点为空</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Node enq(final Node node) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;不断循环直到成功</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Node t &#x3D; tail;</span><br><span class=\"line\">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;第一种情况，未初始化队列</span><br><span class=\"line\">            if (compareAndSetHead(new Node()))</span><br><span class=\"line\">                tail &#x3D; head;</span><br><span class=\"line\">        &#125; else &#123;&#x2F;&#x2F;队列已经初始化</span><br><span class=\"line\">            node.prev &#x3D; t; &#x2F;&#x2F;连接node的前驱</span><br><span class=\"line\">            if (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next &#x3D; node;&#x2F;&#x2F;设置tail的后继</span><br><span class=\"line\">                return t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>enq方法，如果队列没有初始化，进行初始化后，继续循环。<br>\n继续执行循环的队列已经初始化，然后用先设置它的pre,然后用，cas进行设置tail，失败则重试。成功设置tail的后继结点为当前结点并返回该结点。</p>\n<p>下图展示了从初始化到添加了一个结点的变化过程，也就是说 <strong>head引用的结点是无效的结点,并不关联有效的线程</strong><br>\n<img src=\"imgs/xuyuntian/thread/aqs/aqs_node_change.png\" alt=\"\"></p>\n<h3 id=\"acquirequeued方法\">acquireQueued方法<a title=\"#acquirequeued方法\" href=\"#acquirequeued方法\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class=\"line\">    boolean failed &#x3D; true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        boolean interrupted &#x3D; false;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p &#x3D; node.predecessor();</span><br><span class=\"line\">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;&#x2F;&#x2F;它的前驱是head，且获取锁成功</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class=\"line\">                failed &#x3D; false;</span><br><span class=\"line\">                return interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F;进行2步操作 1.给当前node设置线程的状态</span><br><span class=\"line\">            &#x2F;&#x2F;第一步成功，挂起线程。</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted &#x3D; true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>acquireQueued方法有以下作用:</p>\n<ol>\n<li>尝试抢锁，（如果是队列中第一个有效的线程）</li>\n<li>挂起线程</li>\n</ol>\n<p>如果抢锁成功后，会将head设置为当前结点(在addWaiter方法这节中已经解释过，<strong>head结点是无效的</strong>)，然后返回<br>\n它调用了shouldParkAfterFailedAcquire方法，该方法代码如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class=\"line\">    int ws &#x3D; pred.waitStatus;</span><br><span class=\"line\">    if (ws &#x3D;&#x3D; Node.SIGNAL) &#x2F;&#x2F;设置过pred的值后进入</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    if (ws &gt; 0) &#123;&#x2F;&#x2F;这种情况暂时不考虑</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class=\"line\">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class=\"line\">        pred.next &#x3D; node;</span><br><span class=\"line\">    &#125; else &#123;&#x2F;&#x2F;pred的值如果没设置进入</span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>pred的初始值为0,所以会用cas设置它的值为Node.SIGNAL（-1）后返回false,然后继续acquireQueued中的循环，如果不能抢锁，或者抢锁失败，重新执行该方法，然后返回true,调用parkAndCheckInterrupt方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class=\"line\">    LockSupport.park(this);&#x2F;&#x2F;挂起当前线程</span><br><span class=\"line\">    return Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程获取锁的状态图如下<br>\n<img src=\"imgs/xuyuntian/thread/aqs/aqs_e_lock_state.png\" alt=\"\"></p>\n<p>注意到，在非公平锁中它的lock方法和tryAcquire方法会进行抢锁，如果抢到了锁它并不会进入队列。所以说，非公平锁在非队列中的线程如果抢到了锁，它会第一个执行。如果没抢到会进入队列。在队列中的线程执行顺序遵守FIFO。</p>\n<h2 id=\"锁的释放\">锁的释放<a title=\"#锁的释放\" href=\"#锁的释放\"></a></h2>\n<p>ReentrantLock中unlock()的方法如下，它调用了sync的release方法,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void unlock() &#123;</span><br><span class=\"line\">    sync.release(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>release方法来自于AbstractQueuedSynchronizer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean release(int arg) &#123;</span><br><span class=\"line\">    if (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h &#x3D; head;</span><br><span class=\"line\">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class=\"line\">            unparkSuccessor(h);&#x2F;&#x2F;唤醒线程</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>realse方法会调用tryRelease方法，tryRelease会减少state，如果state为0则释放成功.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected final boolean tryRelease(int releases) &#123;</span><br><span class=\"line\">    int c &#x3D; getState() - releases;</span><br><span class=\"line\">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class=\"line\">        throw new IllegalMonitorStateException();</span><br><span class=\"line\">    boolean free &#x3D; false;</span><br><span class=\"line\">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        free &#x3D; true;</span><br><span class=\"line\">        setExclusiveOwnerThread(null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    return free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>释放成功时候会调用unparkSuccessor去唤醒队列中的线程。<br>\n唤醒的逻辑如下:</p>\n<ol>\n<li>尝试唤醒head的下个结点(head结点是无效的)</li>\n<li>head的下个结点状态无效，或者为空，从tail扫描到head,找出第一个有效的。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void unparkSuccessor(Node node) &#123;</span><br><span class=\"line\">    int ws &#x3D; node.waitStatus;</span><br><span class=\"line\">    if (ws &lt; 0)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class=\"line\">    Node s &#x3D; node.next;&#x2F;&#x2F;一般情况下，唤醒head的下个结点</span><br><span class=\"line\">    &#x2F;&#x2F;找到第一个状态有效的结点(特殊情况)</span><br><span class=\"line\">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class=\"line\">        s &#x3D; null;</span><br><span class=\"line\">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class=\"line\">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class=\"line\">                s &#x3D; t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (s !&#x3D; null)</span><br><span class=\"line\">        LockSupport.unpark(s.thread);&#x2F;&#x2F;唤醒当前线程</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，它的状态图如下：<br>\n<img src=\"imgs/xuyuntian/thread/aqs/aqs_e_full_state.png\" alt=\"\"></p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>ReentrantLock中的Sync和它的子类只重写了tryAcquire,tryRelease,isHeldExclusively，便实现了排他锁。<br>\n这里并没有详细介绍公平锁。公平锁与非公平锁的最大区别在于抢锁。使用非公平锁，线程可能出现优先级比队列中优先级高的情况（只要它抢到了锁）。而公平锁抢锁之前会判断它队列中是否有其他线程。如果没有才进行抢锁。</p>\n<h2 id=\"推荐阅读\">推荐阅读<a title=\"#推荐阅读\" href=\"#推荐阅读\"></a></h2>\n<blockquote>\n<p><a href=\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\" target=\"_blank\">从ReentrantLock的实现看AQS的原理及应用</a></p>\n</blockquote>\n","prev":{"title":"Java AQS 之读写锁","link":"2021/02/24/xuyuntian/java/io_and_thread/aqs_rw"},"next":{"title":"java Unsafe类","link":"2021/02/19/xuyuntian/java/unsafe"},"plink":"http://example.com/2021/02/23/xuyuntian/java/io_and_thread/aqs_e/","toc":[{"id":"java-aqs-之排它锁","title":"Java AQS 之排它锁","index":"1","children":[{"id":"从reentrantlock出发","title":"从ReentrantLock出发","index":"1.1","children":[{"id":"1.从非公平锁出发来深入了解它的实现","title":"1.从非公平锁出发来深入了解它的实现","index":"1.1.1"}]},{"id":"abstractqueuedsynchronizer","title":"AbstractQueuedSynchronizer","index":"1.2","children":[{"id":"aqs的字段","title":"aqs的字段","index":"1.2.1"},{"id":"node","title":"Node","index":"1.2.2"},{"id":"addwaiter方法","title":"addWaiter方法","index":"1.2.3"},{"id":"acquirequeued方法","title":"acquireQueued方法","index":"1.2.4"}]},{"id":"锁的释放","title":"锁的释放","index":"1.3"},{"id":"总结","title":"总结","index":"1.4"},{"id":"推荐阅读","title":"推荐阅读","index":"1.5"}]}]}