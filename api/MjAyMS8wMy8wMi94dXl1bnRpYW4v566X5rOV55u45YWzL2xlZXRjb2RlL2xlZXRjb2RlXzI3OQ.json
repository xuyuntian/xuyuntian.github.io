{"title":"279. Perfect Squares","date":"2021-03-02T11:01:00.000Z","date_formatted":{"ll":"Mar 2, 2021","L":"03/02/2021","MM-DD":"03-02"},"link":"2021/03/02/xuyuntian/算法相关/leetcode/leetcode_279","tags":["leetcode"],"categories":["算法"],"updated":"2021-03-02T02:06:14.078Z","content":"<h1 id=\"279.-perfect-squares\">279. Perfect Squares<a title=\"#279.-perfect-squares\" href=\"#279.-perfect-squares\"></a></h1>\n<p><a href=\"https://leetcode.com/problems/perfect-squares/\" target=\"_blank\">原题</a></p>\n<blockquote>\n<p>给你一个数n，用最小数量的square numbers来组成它(它们的和)</p>\n</blockquote>\n<p>例子1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 12</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>\n<p>例子2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 13</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<h3 id=\"广度优先搜索\">广度优先搜索<a title=\"#广度优先搜索\" href=\"#广度优先搜索\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int numSquares(int n) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;广度优先搜索</span><br><span class=\"line\">        List&lt;Integer&gt; cadidates &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for(int i &#x3D; 1;i*i &lt;&#x3D; n; i++)&#123;</span><br><span class=\"line\">            cadidates.add(i*i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HashSet&lt;Integer&gt; v &#x3D; new HashSet&lt;&gt;();</span><br><span class=\"line\">        Node nd &#x3D; new Node();</span><br><span class=\"line\">        nd.step &#x3D; 0;</span><br><span class=\"line\">        nd.remain &#x3D; n;</span><br><span class=\"line\">        Deque&lt;Node&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class=\"line\">        q.offer(nd);</span><br><span class=\"line\">        while(q.size() &gt; 0)&#123;</span><br><span class=\"line\">            Node cur &#x3D; q.poll();</span><br><span class=\"line\">            if(cur.remain &#x3D;&#x3D; 0) return cur.step;</span><br><span class=\"line\">            for(int val: cadidates)&#123;</span><br><span class=\"line\">                if(cur.remain &lt; val) break;</span><br><span class=\"line\">                if(v.contains(cur.remain - val)) continue;</span><br><span class=\"line\">                v.add(cur.remain - val);</span><br><span class=\"line\">                q.offer(cur.sub(val));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static class Node&#123;</span><br><span class=\"line\">        int step;</span><br><span class=\"line\">        int remain;</span><br><span class=\"line\">        </span><br><span class=\"line\">        public Node sub(int num)&#123;</span><br><span class=\"line\">            Node res &#x3D; new Node();</span><br><span class=\"line\">            res.step &#x3D; step +1;</span><br><span class=\"line\">            res.remain &#x3D; remain - num;</span><br><span class=\"line\">            return res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用平方数不断降低n</li>\n<li>返回第一个第一n为0的step</li>\n</ul>\n<blockquote>\n<p>广度优先搜索要避免重复搜索，否则会timeout,当剩余的数已经出现过(说明step更少的情况下已经到达了它)，便不需要搜索它了，因为它必定不是最优解</p>\n</blockquote>\n<h3 id=\"动态规划\">动态规划<a title=\"#动态规划\" href=\"#动态规划\"></a></h3>\n<h4 id=\"自底向上\">自底向上<a title=\"#自底向上\" href=\"#自底向上\"></a></h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int numSquares(int n) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;dp[i] </span><br><span class=\"line\">        int[] dp &#x3D; new int[n+1];</span><br><span class=\"line\">        for(int i &#x3D; 1;i*i &lt;&#x3D; n;i++)&#123;</span><br><span class=\"line\">            dp[i*i] &#x3D; 1;&#x2F;&#x2F;本身是 square numbers 只需要一个</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;递归条件:这里有个隐藏的条件,如果i不是square numbers，它可以由一个square numbers和其他的数组成</span><br><span class=\"line\">        &#x2F;&#x2F; if i not in square numbers;</span><br><span class=\"line\">        &#x2F;&#x2F; dp[i] &#x3D; min(dp[i-x1],dp[i-x2],dp[i-x3],...dp[i-xn]) + 1; &#x2F;&#x2F;xn in  square numbers</span><br><span class=\"line\">       for(int i &#x3D; 2;i &lt;&#x3D; n;i++)&#123;</span><br><span class=\"line\">           if(dp[i] !&#x3D; 0)continue;</span><br><span class=\"line\">           int min  &#x3D; Integer.MAX_VALUE;</span><br><span class=\"line\">           for(int j &#x3D; 1;j*j &lt;&#x3D; i;j++)&#123;</span><br><span class=\"line\">               min &#x3D; Math.min( dp[i-j*j],min);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           dp[i] &#x3D; 1 + min;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       return dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自顶向下\">自顶向下<a title=\"#自顶向下\" href=\"#自顶向下\"></a></h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int numSquares(int n) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;动态规划自顶向下</span><br><span class=\"line\">        Integer[] dp &#x3D; new Integer[n+1];</span><br><span class=\"line\">        for(int i &#x3D; 1;i*i &lt;&#x3D; n;i++)&#123;</span><br><span class=\"line\">            dp[i*i] &#x3D; 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dfs(n,dp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public int dfs(int n,Integer[] dp)&#123;</span><br><span class=\"line\">        if(dp[n] !&#x3D; null) return dp[n];</span><br><span class=\"line\">        Integer min &#x3D; Integer.MAX_VALUE;</span><br><span class=\"line\">        for(int i&#x3D; 1;i*i &lt;&#x3D; n;i++)&#123;</span><br><span class=\"line\">            min &#x3D; Math.min(min,dfs(n-i*i,dp));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n] &#x3D; min + 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"说明\">说明<a title=\"#说明\" href=\"#说明\"></a></h4>\n<p>使用动态规划，必须要知道递推条件:<br>\n这里的递推条件就是 dp[i] = x + 1; x是dp[i-k]的最小值，k 是平方数且小于i,i自身不是平方数</p>\n<p>自底向上的核心思想是用dp[i]的底部条件然后推导出dp[i];<br>\n自顶向下的核心思想是用dp[n]向下推导，直到能计算为止，且缓存计算过的值，不作重复计算。<br>\n本质上上它们都是先计算底部条件，只不过写法不同。</p>\n","prev":{"title":"反转链表","link":"2021/03/04/xuyuntian/算法相关/策略/reverse_list"},"next":{"title":"Product of Array Except Self","link":"2021/02/28/xuyuntian/算法相关/leetcode/leetcode_238"},"plink":"http://example.com/2021/03/02/xuyuntian/算法相关/leetcode/leetcode_279/","toc":[{"id":"279.-perfect-squares","title":"279. Perfect Squares","index":"1","children":[{"id":"个人思路","title":"个人思路","index":"1.1","children":[{"id":"广度优先搜索","title":"广度优先搜索","index":"1.1.1"},{"id":"动态规划","title":"动态规划","index":"1.1.2"}]}]}]}