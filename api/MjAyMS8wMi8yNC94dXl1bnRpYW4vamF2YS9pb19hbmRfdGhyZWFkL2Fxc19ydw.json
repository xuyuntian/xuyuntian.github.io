{"title":"Java AQS 之读写锁","date":"2021-02-24T11:30:01.000Z","date_formatted":{"ll":"Feb 24, 2021","L":"02/24/2021","MM-DD":"02-24"},"link":"2021/02/24/xuyuntian/java/io_and_thread/aqs_rw","tags":["基础知识","线程"],"categories":["java"],"updated":"2021-02-26T06:28:42.365Z","content":"<h1 id=\"读写锁\">读写锁<a title=\"#读写锁\" href=\"#读写锁\"></a></h1>\n<p>在读多写少的情况下如果对读写不加以区分的话，锁的效率会特别低。对于一种极端情况下，所有线程都只有读操作的话，加锁会严重影响效率。为了针对这种情况，java也实现了一种读写锁 ReentrantReadWriteLock。</p>\n<h2 id=\"简介\">简介<a title=\"#简介\" href=\"#简介\"></a></h2>\n<p>ReentrantReadWriteLock的实现依赖于AQS。<br>\n它有以下核心成员</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final ReentrantReadWriteLock.ReadLock readerLock;&#x2F;&#x2F;读锁</span><br><span class=\"line\">private final ReentrantReadWriteLock.WriteLock writerLock;&#x2F;&#x2F;写锁</span><br><span class=\"line\">final Sync sync;&#x2F;&#x2F;公平锁或者非公平锁</span><br></pre></td></tr></table></figure>\n<p>它有5个静态内部类</p>\n<ul>\n<li>Sync</li>\n<li>NonfairSync</li>\n<li>FairSync</li>\n<li>ReadLock</li>\n<li>WriteLock</li>\n</ul>\n<p>它们直接的关系入下图，可以看到ReadLock和WriteLock内部有个字段sync，它有2个实现：<br>\nFairSync和NonfairSync，默认情况下，ReentrantReadWriteLock，使用的是非公平锁。<br>\n<img src=\"imgs/xuyuntian/thread/aqs/rw_01.png\" alt=\"\"><br>\n<img src=\"imgs/xuyuntian/thread/aqs/rw_02.png\" alt=\"\"></p>\n<h3 id=\"关于公平锁和非公平锁\">关于公平锁和非公平锁<a title=\"#关于公平锁和非公平锁\" href=\"#关于公平锁和非公平锁\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class FairSync extends Sync &#123;</span><br><span class=\"line\">    private static final long serialVersionUID &#x3D; -2274990926593161451L;</span><br><span class=\"line\">    final boolean writerShouldBlock() &#123;</span><br><span class=\"line\">        return hasQueuedPredecessors();&#x2F;&#x2F;判断队列中是否有排队的线程</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final boolean readerShouldBlock() &#123;</span><br><span class=\"line\">        return hasQueuedPredecessors();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final class NonfairSync extends Sync &#123;</span><br><span class=\"line\">    private static final long serialVersionUID &#x3D; -8159625535654395037L;</span><br><span class=\"line\">    final boolean writerShouldBlock() &#123;</span><br><span class=\"line\">        return false; &#x2F;&#x2F; writers can always barge</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    final boolean readerShouldBlock() &#123;</span><br><span class=\"line\">        return apparentlyFirstQueuedIsExclusive();&#x2F;&#x2F;判断排队的第一个线程是否是等待写锁</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>公平锁与非公平锁的区别在于writerShouldBlock和readerShouldBlock的实现方法，实现方式的不同会改变后面抢锁的逻辑。</p>\n<h2 id=\"读锁\">读锁<a title=\"#读锁\" href=\"#读锁\"></a></h2>\n<p>接下来，分析读锁的lock()和unlock()方法，来深入了解读锁的实现。</p>\n<h3 id=\"lock()\">lock()<a title=\"#lock()\" href=\"#lock()\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void lock() &#123;</span><br><span class=\"line\">    sync.acquireShared(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，lock()方法实际上调用了sync的acquireShared方法，现在进入acquireShared方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireShared(int arg) &#123;</span><br><span class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>acquireShared属于AbstractQueuedSynchronizer,该方法内部的逻辑如下</p>\n<ol>\n<li>尝试调用tryAcquireShared方法，如果失败的话会返回一个小于0的数执行第2步</li>\n<li>调用doAcquireShared</li>\n</ol>\n<p>先观察方法<strong>tryAcquireShared</strong>,它必须被重写才能使用，Sync已经重写了它：</p>\n<p>在解释它之前先分析Sync的结构:<br>\n<img src=\"imgs/xuyuntian/thread/aqs/rw_03.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int SHARED_SHIFT   &#x3D; 16;</span><br><span class=\"line\">static final int SHARED_UNIT    &#x3D; (1 &lt;&lt; SHARED_SHIFT);</span><br><span class=\"line\">static final int MAX_COUNT      &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class=\"line\">static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class=\"line\">private transient ThreadLocalHoldCounter readHolds; &#x2F;&#x2F;维护每个读线程的状态</span><br><span class=\"line\">private transient HoldCounter cachedHoldCounter;&#x2F;&#x2F;缓存最近的一个计数器</span><br><span class=\"line\">private transient Thread firstReader &#x3D; null;&#x2F;&#x2F;最早持有读锁的线程，且没有释放读锁</span><br><span class=\"line\">private transient int firstReaderHoldCount;&#x2F;&#x2F;最早持有读锁线程读锁的值</span><br></pre></td></tr></table></figure>\n<p>Sync将state分成2部分来存储值，低16位存写锁的值，高16位存读锁的值,通过 将state作为以下方法的参数计算得到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class=\"line\">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; </span><br></pre></td></tr></table></figure>\n<p>现在继续分析tryAcquireShared方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected final int tryAcquireShared(int unused) &#123;</span><br><span class=\"line\">    Thread current &#x3D; Thread.currentThread();</span><br><span class=\"line\">    int c &#x3D; getState();</span><br><span class=\"line\">    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">        getExclusiveOwnerThread() !&#x3D; current)</span><br><span class=\"line\">        return -1;&#x2F;&#x2F;如果读锁的值不是0，且当前线程没有持有写锁</span><br><span class=\"line\">    int r &#x3D; sharedCount(c);</span><br><span class=\"line\">    if (!readerShouldBlock() &amp;&amp;</span><br><span class=\"line\">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class=\"line\">        compareAndSetState(c, c + SHARED_UNIT)) &#123;&#x2F;&#x2F;读锁没有被阻塞，且读锁的值没有到达上限，cas设置读锁的值成功。</span><br><span class=\"line\">        if (r &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;读锁没有被持有</span><br><span class=\"line\">            firstReader &#x3D; current;</span><br><span class=\"line\">            firstReaderHoldCount &#x3D; 1;</span><br><span class=\"line\">        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;&#x2F;&#x2F;当前线程持有读锁，重入</span><br><span class=\"line\">            firstReaderHoldCount++;</span><br><span class=\"line\">        &#125; else &#123;&#x2F;&#x2F;重新从缓存，或者ThreadLoal中得到值。</span><br><span class=\"line\">            HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class=\"line\">            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class=\"line\">                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class=\"line\">            else if (rh.count &#x3D;&#x3D; 0)</span><br><span class=\"line\">                readHolds.set(rh);</span><br><span class=\"line\">            rh.count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 1;&#x2F;&#x2F;这种情况下，获取锁成功返回-1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return fullTryAcquireShared(current);&#x2F;&#x2F;这种情况下不断重试</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>tryAcquireShared会初步去尝试获取锁，如果被阻塞（公平锁和非公平锁有2种实现），或者锁到达上限，或CAS设置state失败都会进入<strong>fullTryAcquireShared</strong>方法<br>\n下面分析该方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class=\"line\">    HoldCounter rh &#x3D; null;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        int c &#x3D; getState();</span><br><span class=\"line\">        if (exclusiveCount(c) !&#x3D; 0) &#123;</span><br><span class=\"line\">            if (getExclusiveOwnerThread() !&#x3D; current)</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">        &#125; else if (readerShouldBlock()) &#123;&#x2F;&#x2F;公平锁和非公平锁情况不一样，总之，如果线程不是重入读锁的情况，直接会失败。</span><br><span class=\"line\">            &#x2F;&#x2F; Make sure we&#39;re not acquiring read lock reentrantly</span><br><span class=\"line\">            if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (rh &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">                    rh &#x3D; cachedHoldCounter;</span><br><span class=\"line\">                    if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current)) &#123;</span><br><span class=\"line\">                        rh &#x3D; readHolds.get();</span><br><span class=\"line\">                        if (rh.count &#x3D;&#x3D; 0)</span><br><span class=\"line\">                            readHolds.remove();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (rh.count &#x3D;&#x3D; 0)</span><br><span class=\"line\">                    return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT)&#x2F;&#x2F;超出容量上限， 直接抛出异常</span><br><span class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class=\"line\">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;&#x2F;&#x2F;CAS设置state,这里SHARED_UNIT为1 &lt;&lt;16 ,能让最高16位的值上升1</span><br><span class=\"line\">            if (sharedCount(c) &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                firstReader &#x3D; current;</span><br><span class=\"line\">                firstReaderHoldCount &#x3D; 1;</span><br><span class=\"line\">            &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class=\"line\">                firstReaderHoldCount++;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (rh &#x3D;&#x3D; null)</span><br><span class=\"line\">                    rh &#x3D; cachedHoldCounter;</span><br><span class=\"line\">                if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class=\"line\">                    rh &#x3D; readHolds.get();</span><br><span class=\"line\">                else if (rh.count &#x3D;&#x3D; 0)</span><br><span class=\"line\">                    readHolds.set(rh);</span><br><span class=\"line\">                rh.count++;</span><br><span class=\"line\">                cachedHoldCounter &#x3D; rh; &#x2F;&#x2F; cache for release</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fullTryAcquireShared方法的逻辑大致如下:</p>\n<ol>\n<li>锁是否被阻塞（基于非公平锁和非公平锁），如果该锁不是重入的读锁，直接失败</li>\n<li>重入锁，或者没有被阻塞，用CAS设置state</li>\n</ol>\n<p><strong>tryAcquireShared</strong>方法失败后会执行<strong>doAcquireShared</strong>方法（来自于AbstractQueuedSynchronizer）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doAcquireShared(int arg) &#123;</span><br><span class=\"line\">    final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;加入到队列中（队列的head不保存有效线程）</span><br><span class=\"line\">    boolean failed &#x3D; true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        boolean interrupted &#x3D; false;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p &#x3D; node.predecessor();</span><br><span class=\"line\">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class=\"line\">                int r &#x3D; tryAcquireShared(arg);&#x2F;&#x2F;尝试抢锁</span><br><span class=\"line\">                if (r &gt;&#x3D; 0) &#123;&#x2F;&#x2F;抢锁成功，将header设置为该节点，</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);&#x2F;&#x2F;这个方法很特殊先标记</span><br><span class=\"line\">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class=\"line\">                    if (interrupted)</span><br><span class=\"line\">                        selfInterrupt();</span><br><span class=\"line\">                    failed &#x3D; false;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F;处理waitStates后，挂起线程</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted &#x3D; true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的基本逻辑：</p>\n<ol>\n<li>创建新节点关联当前线程</li>\n<li>如果节点是队列中第一个有效节点，抢锁</li>\n<li>设置waitStatus后，继续执行循环再次抢锁，失败后挂起线程。</li>\n</ol>\n<p>这里有个逻辑</p>\n<blockquote>\n<p>setHeadAndPropagate(node, r);<br>\n这断逻辑很重要,它的实现如下：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class=\"line\">    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class=\"line\">    setHead(node);</span><br><span class=\"line\">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class=\"line\">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class=\"line\">        Node s &#x3D; node.next;</span><br><span class=\"line\">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class=\"line\">            doReleaseShared();&#x2F;&#x2F;唤醒在队列中的线程</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>读锁传入的参数r为1，所以必定进入判断语句块。简而言之，在队列中等待读锁的线程一旦获取到读锁，它会唤醒队列中下个是共享锁的等待线程。</p>\n<h3 id=\"unlock()\">unlock()<a title=\"#unlock()\" href=\"#unlock()\"></a></h3>\n<p>下面介绍unlock方法，unlock()方法调用了aqs的releaseShared方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void unlock() &#123;</span><br><span class=\"line\">    sync.releaseShared(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>relaseShared方法尝试调用tryReleaseShared方法，如果该共享锁的state为0，它会执行<br>\ndoReleaseShared方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean releaseShared(int arg) &#123;</span><br><span class=\"line\">    if (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面单独观察tryReleaseShared</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class=\"line\">    Thread current &#x3D; Thread.currentThread();</span><br><span class=\"line\">    if (firstReader &#x3D;&#x3D; current) &#123;&#x2F;&#x2F;第一种情况，当前锁的线程是最近获取锁的</span><br><span class=\"line\">        &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class=\"line\">        if (firstReaderHoldCount &#x3D;&#x3D; 1)</span><br><span class=\"line\">            firstReader &#x3D; null;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            firstReaderHoldCount--;</span><br><span class=\"line\">    &#125; else &#123;&#x2F;&#x2F;是其他线程释放</span><br><span class=\"line\">        HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class=\"line\">        if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class=\"line\">            rh &#x3D; readHolds.get();</span><br><span class=\"line\">        int count &#x3D; rh.count;</span><br><span class=\"line\">        if (count &lt;&#x3D; 1) &#123;</span><br><span class=\"line\">            readHolds.remove();</span><br><span class=\"line\">            if (count &lt;&#x3D; 0)</span><br><span class=\"line\">                throw unmatchedUnlockException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        --rh.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (;;) &#123;&#x2F;&#x2F;不断cas直到成功</span><br><span class=\"line\">        int c &#x3D; getState();</span><br><span class=\"line\">        int nextc &#x3D; c - SHARED_UNIT;</span><br><span class=\"line\">        if (compareAndSetState(c, nextc))</span><br><span class=\"line\">            &#x2F;&#x2F; Releasing the read lock has no effect on readers,</span><br><span class=\"line\">            &#x2F;&#x2F; but it may allow waiting writers to proceed if</span><br><span class=\"line\">            &#x2F;&#x2F; both read and write locks are now free.</span><br><span class=\"line\">            return nextc &#x3D;&#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的逻辑比较简单</p>\n<ol>\n<li>先减少该线程的state</li>\n<li>然后减少总的state</li>\n</ol>\n<p>当tryReleaseShared后state为0(所有共享锁都不持有锁了)执行doReleaseShared方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doReleaseShared() &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Node h &#x3D; head;</span><br><span class=\"line\">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class=\"line\">            int ws &#x3D; h.waitStatus;</span><br><span class=\"line\">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class=\"line\">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class=\"line\">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class=\"line\">                unparkSuccessor(h);&#x2F;&#x2F;唤醒h下个节点关联的线程</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class=\"line\">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class=\"line\">            break;&#x2F;&#x2F;唤醒线程后终止循环，否则说明head被其他线程改变。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>doReleaseShared(）会出现多个线程竞争的情况。（写锁获取锁的时候调用 setHeadAndPropagate唤醒下个共享锁节点) 。<br>\n在一般情况下，唤醒线程后会直接终止循环.</p>\n<h2 id=\"写锁\">写锁<a title=\"#写锁\" href=\"#写锁\"></a></h2>\n<h3 id=\"lock()-1\">lock()<a title=\"#lock()-1\" href=\"#lock()-1\"></a></h3>\n<p>逻辑和排他锁差不多，这里不再介绍acquire,tryAcquire的逻辑有所区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class=\"line\">    Thread current &#x3D; Thread.currentThread();</span><br><span class=\"line\">    int c &#x3D; getState();</span><br><span class=\"line\">    int w &#x3D; exclusiveCount(c);</span><br><span class=\"line\">    if (c !&#x3D; 0) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; (Note: if c !&#x3D; 0 and w &#x3D;&#x3D; 0 then shared count !&#x3D; 0)</span><br><span class=\"line\">        if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())</span><br><span class=\"line\">            return false;&#x2F;&#x2F;共享锁数量不为0</span><br><span class=\"line\">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F; Reentrant acquire</span><br><span class=\"line\">        setState(c + acquires);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (writerShouldBlock() ||</span><br><span class=\"line\">        !compareAndSetState(c, c + acquires))</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    setExclusiveOwnerThread(current);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法熟悉判断共享锁state是不是0，以及排它锁的state是否超出上限（重入）。<br>\n不是重入的话CAS设置state,失败返回false;</p>\n<h3 id=\"unlock()-1\">unlock()<a title=\"#unlock()-1\" href=\"#unlock()-1\"></a></h3>\n<p>用的还是排它锁的逻辑，这里不再解释它。只不过tryRelease方法有所不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected final boolean tryRelease(int releases) &#123;</span><br><span class=\"line\">    if (!isHeldExclusively())</span><br><span class=\"line\">        throw new IllegalMonitorStateException();&#x2F;&#x2F;只能有一个写锁能尝试该操作，否则报错</span><br><span class=\"line\">    int nextc &#x3D; getState() - releases;</span><br><span class=\"line\">    boolean free &#x3D; exclusiveCount(nextc) &#x3D;&#x3D; 0;&#x2F;&#x2F;获取写锁的state</span><br><span class=\"line\">    if (free)</span><br><span class=\"line\">        setExclusiveOwnerThread(null);</span><br><span class=\"line\">    setState(nextc);</span><br><span class=\"line\">    return free;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<h3 id=\"公平锁和非公平锁\">公平锁和非公平锁<a title=\"#公平锁和非公平锁\" href=\"#公平锁和非公平锁\"></a></h3>\n<p>对于写锁来说</p>\n<ul>\n<li>公平锁： 会判断队列中是否存在其他等待的线程,然后再抢锁</li>\n<li>非公平锁：直接抢锁</li>\n</ul>\n<p>对于读锁来说</p>\n<ul>\n<li>公平锁：会判断队列中是否存在其他等待的线程,然后再抢锁</li>\n<li>非公平锁：判断队列中第一个等待的线程是否是写锁，否，直接抢锁</li>\n</ul>\n<h3 id=\"读锁和写锁\">读锁和写锁<a title=\"#读锁和写锁\" href=\"#读锁和写锁\"></a></h3>\n<p>读锁为共享锁，写锁为排它锁</p>\n<p>读锁：</p>\n<ul>\n<li>获取锁： 其他线程如果持有写锁，则会被挂起</li>\n<li>释放锁：释放锁后，如果没有线程持有读锁，进行唤醒队列中的第一个线程</li>\n</ul>\n<blockquote>\n<p>获取锁之后，如果队列中第一个线程等待共享锁，则被唤醒</p>\n</blockquote>\n<p>写锁：</p>\n<ul>\n<li>获取锁： 如果其他线程持有写锁或者读锁会被挂起</li>\n<li>释放锁：唤醒队列中第一个线程</li>\n</ul>\n","prev":{"title":"Java AQS 之条件队列","link":"2021/02/25/xuyuntian/java/io_and_thread/aqs_c"},"next":{"title":"Java AQS 之排它锁","link":"2021/02/23/xuyuntian/java/io_and_thread/aqs_e"},"plink":"http://example.com/2021/02/24/xuyuntian/java/io_and_thread/aqs_rw/","toc":[{"id":"读写锁","title":"读写锁","index":"1","children":[{"id":"简介","title":"简介","index":"1.1","children":[{"id":"关于公平锁和非公平锁","title":"关于公平锁和非公平锁","index":"1.1.1"}]},{"id":"读锁","title":"读锁","index":"1.2","children":[{"id":"lock()","title":"lock()","index":"1.2.1"},{"id":"unlock()","title":"unlock()","index":"1.2.2"}]},{"id":"写锁","title":"写锁","index":"1.3","children":[{"id":"lock()-1","title":"lock()","index":"1.3.1"},{"id":"unlock()-1","title":"unlock()","index":"1.3.2"}]},{"id":"总结","title":"总结","index":"1.4","children":[{"id":"公平锁和非公平锁","title":"公平锁和非公平锁","index":"1.4.1"},{"id":"读锁和写锁","title":"读锁和写锁","index":"1.4.2"}]}]}]}