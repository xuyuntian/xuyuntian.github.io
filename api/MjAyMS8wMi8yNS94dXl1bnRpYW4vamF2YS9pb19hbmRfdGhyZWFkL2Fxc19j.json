{"title":"Java AQS 之条件队列","date":"2021-02-25T11:30:01.000Z","date_formatted":{"ll":"Feb 25, 2021","L":"02/25/2021","MM-DD":"02-25"},"link":"2021/02/25/xuyuntian/java/io_and_thread/aqs_c","tags":["基础知识","线程"],"categories":["java"],"updated":"2021-02-26T06:28:39.493Z","content":"<h1 id=\"java-aqs-之条件队列\">Java AQS 之条件队列<a title=\"#java-aqs-之条件队列\" href=\"#java-aqs-之条件队列\"></a></h1>\n<p>实现一个交替打印奇数和偶数程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock l &#x3D; new ReentrantLock();</span><br><span class=\"line\">Condition c &#x3D; l.newCondition();</span><br><span class=\"line\">Runnable a &#x3D; () -&gt; &#123;</span><br><span class=\"line\">    for(;num &lt; 200;)&#123;</span><br><span class=\"line\">        l.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(num % 2 &#x3D;&#x3D;0)c.await();&#x2F;&#x2F;释放该线程的锁，挂起线程</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;&quot;+num++);</span><br><span class=\"line\">            c.signal();&#x2F;&#x2F;通知在条件队列中的第一个线程</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            l.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Runnable b &#x3D; () -&gt; &#123;</span><br><span class=\"line\">    for(;num &lt; 200;)&#123;</span><br><span class=\"line\">        l.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if(num % 2 !&#x3D;0)c.await();</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;&quot;+num++);</span><br><span class=\"line\">            c.signal();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            l.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">new Thread(a,&quot;打印奇数:&quot;).start();</span><br><span class=\"line\">new Thread(b,&quot;打印偶数:&quot;).start();</span><br></pre></td></tr></table></figure>\n<p>aqs内部有个内部类ConditionObject实现了Condition接口。</p>\n<h2 id=\"conditionobject基本结构\">ConditionObject基本结构<a title=\"#conditionobject基本结构\" href=\"#conditionobject基本结构\"></a></h2>\n<p><img src=\"imgs/xuyuntian/thread/aqs/aqs_condition_obj.png\" alt=\"\" class=\"φcx\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private transient Node firstWaiter;&#x2F;&#x2F;第一个等待的节点</span><br><span class=\"line\">private transient Node lastWaiter;&#x2F;&#x2F;最后一个等待的节点</span><br></pre></td></tr></table></figure>\n<p>ConditionObject作为一个内部类，它会维护一个对外部类的引用。下面详细分析条件队列是如何通过signal和await方法来操作当前线程和通知其他线程的。</p>\n<h3 id=\"signal()方法\">signal()方法<a title=\"#signal()方法\" href=\"#signal()方法\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void signal() &#123;</span><br><span class=\"line\">    if (!isHeldExclusively())</span><br><span class=\"line\">        throw new IllegalMonitorStateException();</span><br><span class=\"line\">    Node first &#x3D; firstWaiter;</span><br><span class=\"line\">    if (first !&#x3D; null)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>signal方法首先会判断当前线程是不是持有锁的线程，否则抛出异常。若队列中存在等待的线程执行<br>\ndoSignal方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doSignal(Node first) &#123;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)</span><br><span class=\"line\">            lastWaiter &#x3D; null;</span><br><span class=\"line\">        first.nextWaiter &#x3D; null;</span><br><span class=\"line\">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class=\"line\">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这循环体的意思是执行transferForSignal方法直到成功或者到达队列尾部。在正常情况下只执行一次便成功。</p>\n<p>观察transferForSignal方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final boolean transferForSignal(Node node) &#123;</span><br><span class=\"line\">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    Node p &#x3D; enq(node);&#x2F;&#x2F;将该节点放入同步队列</span><br><span class=\"line\">    int ws &#x3D; p.waitStatus;</span><br><span class=\"line\">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class=\"line\">        LockSupport.unpark(node.thread);    &#x2F;&#x2F;一般情况下 ws为Node.CONDITION（-2），不会进入该语句块</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第一步cas操作，第二步将节点放入同步队列,在不考虑特殊情况下，返回true</p>\n<blockquote>\n<p>也就是说，signal()会将条件队列中的第一个有效节点放入同步队列中</p>\n</blockquote>\n<h3 id=\"await()方法\">await()方法<a title=\"#await()方法\" href=\"#await()方法\"></a></h3>\n<p>await方法相对而言复杂些</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void await() throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();&#x2F;&#x2F;检测线程是否中断</span><br><span class=\"line\">    Node node &#x3D; addConditionWaiter();&#x2F;&#x2F;加入条件队列</span><br><span class=\"line\">    int savedState &#x3D; fullyRelease(node);</span><br><span class=\"line\">    int interruptMode &#x3D; 0;</span><br><span class=\"line\">    while (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(this);</span><br><span class=\"line\">        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class=\"line\">        interruptMode &#x3D; REINTERRUPT;</span><br><span class=\"line\">    if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    if (interruptMode !&#x3D; 0)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它的主要逻辑是：</p>\n<ol>\n<li>加入条件队列</li>\n<li>释放所有锁</li>\n<li>判断是否在同步队列中，否则挂起线程</li>\n<li>线程被唤醒后，执行第三步的判断并进入第5步</li>\n<li>重新获取锁（可能被挂起）</li>\n<li>从条件队列中删除取消的节点</li>\n</ol>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<blockquote>\n<p>Condition的await()方法会让线程将当前锁释放，并挂起线程。而signal()方法会将条件队列中的第一个等待的线程，加入到同步队列。</p>\n</blockquote>\n<p>如何解释打印奇偶的逻辑:<br>\n从num = 0开始。如果奇数线程竞争到锁，调用await()方法，会被挂起。由于在挂起之前会释放锁，所以会通知同步队列中等待偶数线程。<br>\n然后偶数线程便可以获取到锁，执行打印，之后调用signal()方法将奇数线程放到同步队列。偶数线程释放锁后，奇数线程会被重新唤醒，这样不断交替达到交替打印奇偶数的目的。</p>\n","prev":{"title":"Java AQS CountDownLatch","link":"2021/02/26/xuyuntian/java/io_and_thread/aqs_cl"},"next":{"title":"Java AQS 之读写锁","link":"2021/02/24/xuyuntian/java/io_and_thread/aqs_rw"},"plink":"http://example.com/2021/02/25/xuyuntian/java/io_and_thread/aqs_c/","toc":[{"id":"java-aqs-之条件队列","title":"Java AQS 之条件队列","index":"1","children":[{"id":"conditionobject基本结构","title":"ConditionObject基本结构","index":"1.1","children":[{"id":"signal()方法","title":"signal()方法","index":"1.1.1"},{"id":"await()方法","title":"await()方法","index":"1.1.2"}]},{"id":"总结","title":"总结","index":"1.2"}]}]}